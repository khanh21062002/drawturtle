var Module = typeof Module != "undefined" ? Module : {};
const NP_LOGLEVEL = {
	NONE: 0,
	ERROR: 1,
	INFO: 2,
	DEBUG: 3
};
typeof Module.logLevel == "undefined" && (Module.logLevel = NP_LOGLEVEL.INFO);
const logTime = () => {
		let e = new Date;
		return e.toLocaleDateString() + " " + e.toLocaleTimeString([], {
			hour12: !1
		})
	},
	NP_ERROR = (...e) => {
		Module.logLevel < NP_LOGLEVEL.ERROR || console.error(logTime(), "[ERROR]", ...e)
	},
	NP_INFO = (...e) => {
		Module.logLevel < NP_LOGLEVEL.INFO || console.log(logTime(), "[INFO]", ...e)
	},
	NP_DEBUG = (...e) => {
		Module.logLevel < NP_LOGLEVEL.DEBUG || console.log(logTime(), "[DEBUG]", ...e)
	};
Module.print = NP_INFO, Module.printErr = NP_ERROR;
var moduleOverrides = Object.assign({}, Module);
var arguments_ = [];
var thisProgram = "./this.program";
var quit_ = (status, toThrow) => {
	throw toThrow
};
var ENVIRONMENT_IS_WEB = typeof window == "object";
var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
var scriptDirectory = "";

function locateFile(path) {
	if (Module["locateFile"]) {
		return Module["locateFile"](path, scriptDirectory)
	}
	return scriptDirectory + path
}
var read_, readAsync, readBinary, setWindowTitle;

function logExceptionOnExit(e) {
	if (e instanceof ExitStatus) return;
	let toLog = e;
	err("exiting due to exception: " + toLog)
}
var fs;
var nodePath;
var requireNodeFS;
if (ENVIRONMENT_IS_NODE) {
	if (ENVIRONMENT_IS_WORKER) {
		scriptDirectory = require("path").dirname(scriptDirectory) + "/"
	} else {
		scriptDirectory = __dirname + "/"
	}
	requireNodeFS = () => {
		if (!nodePath) {
			fs = require("fs");
			nodePath = require("path")
		}
	};
	read_ = function shell_read(filename, binary) {
		requireNodeFS();
		filename = nodePath["normalize"](filename);
		return fs.readFileSync(filename, binary ? undefined : "utf8")
	};
	readBinary = filename => {
		var ret = read_(filename, true);
		if (!ret.buffer) {
			ret = new Uint8Array(ret)
		}
		return ret
	};
	readAsync = (filename, onload, onerror) => {
		requireNodeFS();
		filename = nodePath["normalize"](filename);
		fs.readFile(filename, function(err, data) {
			if (err) onerror(err);
			else onload(data.buffer)
		})
	};
	if (process["argv"].length > 1) {
		thisProgram = process["argv"][1].replace(/\\/g, "/")
	}
	arguments_ = process["argv"].slice(2);
	if (typeof module != "undefined") {
		module["exports"] = Module
	}
	process["on"]("uncaughtException", function(ex) {
		if (!(ex instanceof ExitStatus)) {
			throw ex
		}
	});
	process["on"]("unhandledRejection", function(reason) {
		throw reason
	});
	quit_ = (status, toThrow) => {
		if (keepRuntimeAlive()) {
			process["exitCode"] = status;
			throw toThrow
		}
		logExceptionOnExit(toThrow);
		process["exit"](status)
	};
	Module["inspect"] = function() {
		return "[Emscripten Module object]"
	}
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
	if (ENVIRONMENT_IS_WORKER) {
		scriptDirectory = self.location.href
	} else if (typeof document != "undefined" && document.currentScript) {
		scriptDirectory = document.currentScript.src
	}
	if (scriptDirectory.indexOf("blob:") !== 0) {
		scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1)
	} else {
		scriptDirectory = ""
	} {
		read_ = url => {
			var xhr = new XMLHttpRequest;
			xhr.open("GET", url, false);
			xhr.send(null);
			return xhr.responseText
		};
		if (ENVIRONMENT_IS_WORKER) {
			readBinary = url => {
				var xhr = new XMLHttpRequest;
				xhr.open("GET", url, false);
				xhr.responseType = "arraybuffer";
				xhr.send(null);
				return new Uint8Array(xhr.response)
			}
		}
		readAsync = (url, onload, onerror) => {
			var xhr = new XMLHttpRequest;
			xhr.open("GET", url, true);
			xhr.responseType = "arraybuffer";
			xhr.onload = () => {
				if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
					onload(xhr.response);
					return
				}
				onerror()
			};
			xhr.onerror = onerror;
			xhr.send(null)
		}
	}
	setWindowTitle = title => document.title = title
} else {}
var out = Module["print"] || console.log.bind(console);
var err = Module["printErr"] || console.warn.bind(console);
Object.assign(Module, moduleOverrides);
moduleOverrides = null;
if (Module["arguments"]) arguments_ = Module["arguments"];
if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
if (Module["quit"]) quit_ = Module["quit"];
var tempRet0 = 0;
var setTempRet0 = value => {
	tempRet0 = value
};
var wasmBinary;
if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
var noExitRuntime = Module["noExitRuntime"] || true;
if (typeof WebAssembly != "object") {
	abort("no native wasm support detected")
}
var wasmMemory;
var ABORT = false;
var EXITSTATUS;

function getCFunc(ident) {
	var func = Module["_" + ident];
	return func
}

function ccall(ident, returnType, argTypes, args, opts) {
	var toC = {
		"string": function(str) {
			var ret = 0;
			if (str !== null && str !== undefined && str !== 0) {
				var len = (str.length << 2) + 1;
				ret = stackAlloc(len);
				stringToUTF8(str, ret, len)
			}
			return ret
		},
		"array": function(arr) {
			var ret = stackAlloc(arr.length);
			writeArrayToMemory(arr, ret);
			return ret
		}
	};

	function convertReturnValue(ret) {
		if (returnType === "string") {
			return UTF8ToString(ret)
		}
		if (returnType === "boolean") return Boolean(ret);
		return ret
	}
	var func = getCFunc(ident);
	var cArgs = [];
	var stack = 0;
	if (args) {
		for (var i = 0; i < args.length; i++) {
			var converter = toC[argTypes[i]];
			if (converter) {
				if (stack === 0) stack = stackSave();
				cArgs[i] = converter(args[i])
			} else {
				cArgs[i] = args[i]
			}
		}
	}
	var ret = func.apply(null, cArgs);

	function onDone(ret) {
		if (stack !== 0) stackRestore(stack);
		return convertReturnValue(ret)
	}
	ret = onDone(ret);
	return ret
}

function cwrap(ident, returnType, argTypes, opts) {
	argTypes = argTypes || [];
	var numericArgs = argTypes.every(function(type) {
		return type === "number"
	});
	var numericRet = returnType !== "string";
	if (numericRet && numericArgs && !opts) {
		return getCFunc(ident)
	}
	return function() {
		return ccall(ident, returnType, argTypes, arguments, opts)
	}
}
var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
	var endIdx = idx + maxBytesToRead;
	var endPtr = idx;
	while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
	if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
		return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr))
	} else {
		var str = "";
		while (idx < endPtr) {
			var u0 = heapOrArray[idx++];
			if (!(u0 & 128)) {
				str += String.fromCharCode(u0);
				continue
			}
			var u1 = heapOrArray[idx++] & 63;
			if ((u0 & 224) == 192) {
				str += String.fromCharCode((u0 & 31) << 6 | u1);
				continue
			}
			var u2 = heapOrArray[idx++] & 63;
			if ((u0 & 240) == 224) {
				u0 = (u0 & 15) << 12 | u1 << 6 | u2
			} else {
				u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63
			}
			if (u0 < 65536) {
				str += String.fromCharCode(u0)
			} else {
				var ch = u0 - 65536;
				str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
			}
		}
	}
	return str
}

function UTF8ToString(ptr, maxBytesToRead) {
	return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ""
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
	if (!(maxBytesToWrite > 0)) return 0;
	var startIdx = outIdx;
	var endIdx = outIdx + maxBytesToWrite - 1;
	for (var i = 0; i < str.length; ++i) {
		var u = str.charCodeAt(i);
		if (u >= 55296 && u <= 57343) {
			var u1 = str.charCodeAt(++i);
			u = 65536 + ((u & 1023) << 10) | u1 & 1023
		}
		if (u <= 127) {
			if (outIdx >= endIdx) break;
			heap[outIdx++] = u
		} else if (u <= 2047) {
			if (outIdx + 1 >= endIdx) break;
			heap[outIdx++] = 192 | u >> 6;
			heap[outIdx++] = 128 | u & 63
		} else if (u <= 65535) {
			if (outIdx + 2 >= endIdx) break;
			heap[outIdx++] = 224 | u >> 12;
			heap[outIdx++] = 128 | u >> 6 & 63;
			heap[outIdx++] = 128 | u & 63
		} else {
			if (outIdx + 3 >= endIdx) break;
			heap[outIdx++] = 240 | u >> 18;
			heap[outIdx++] = 128 | u >> 12 & 63;
			heap[outIdx++] = 128 | u >> 6 & 63;
			heap[outIdx++] = 128 | u & 63
		}
	}
	heap[outIdx] = 0;
	return outIdx - startIdx
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
	return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)
}

function lengthBytesUTF8(str) {
	var len = 0;
	for (var i = 0; i < str.length; ++i) {
		var u = str.charCodeAt(i);
		if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
		if (u <= 127) ++len;
		else if (u <= 2047) len += 2;
		else if (u <= 65535) len += 3;
		else len += 4
	}
	return len
}

function writeArrayToMemory(array, buffer) {
	HEAP8.set(array, buffer)
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
	for (var i = 0; i < str.length; ++i) {
		HEAP8[buffer++ >> 0] = str.charCodeAt(i)
	}
	if (!dontAddNull) HEAP8[buffer >> 0] = 0
}
var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
	buffer = buf;
	Module["HEAP8"] = HEAP8 = new Int8Array(buf);
	Module["HEAP16"] = HEAP16 = new Int16Array(buf);
	Module["HEAP32"] = HEAP32 = new Int32Array(buf);
	Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
	Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
	Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
	Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
	Module["HEAPF64"] = HEAPF64 = new Float64Array(buf)
}
var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
var wasmTable;
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATEXIT__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;

function keepRuntimeAlive() {
	return noExitRuntime
}

function preRun() {
	if (Module["preRun"]) {
		if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
		while (Module["preRun"].length) {
			addOnPreRun(Module["preRun"].shift())
		}
	}
	callRuntimeCallbacks(__ATPRERUN__)
}

function initRuntime() {
	runtimeInitialized = true;
	callRuntimeCallbacks(__ATINIT__)
}

function preMain() {
	callRuntimeCallbacks(__ATMAIN__)
}

function postRun() {
	if (Module["postRun"]) {
		if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
		while (Module["postRun"].length) {
			addOnPostRun(Module["postRun"].shift())
		}
	}
	callRuntimeCallbacks(__ATPOSTRUN__)
}

function addOnPreRun(cb) {
	__ATPRERUN__.unshift(cb)
}

function addOnInit(cb) {
	__ATINIT__.unshift(cb)
}

function addOnPostRun(cb) {
	__ATPOSTRUN__.unshift(cb)
}
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;

function addRunDependency(id) {
	runDependencies++;
	if (Module["monitorRunDependencies"]) {
		Module["monitorRunDependencies"](runDependencies)
	}
}

function removeRunDependency(id) {
	runDependencies--;
	if (Module["monitorRunDependencies"]) {
		Module["monitorRunDependencies"](runDependencies)
	}
	if (runDependencies == 0) {
		if (runDependencyWatcher !== null) {
			clearInterval(runDependencyWatcher);
			runDependencyWatcher = null
		}
		if (dependenciesFulfilled) {
			var callback = dependenciesFulfilled;
			dependenciesFulfilled = null;
			callback()
		}
	}
}

function abort(what) {
	{
		if (Module["onAbort"]) {
			Module["onAbort"](what)
		}
	}
	what = "Aborted(" + what + ")";
	err(what);
	ABORT = true;
	EXITSTATUS = 1;
	what += ". Build with -sASSERTIONS for more info.";
	var e = new WebAssembly.RuntimeError(what);
	throw e
}
var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
	return filename.startsWith(dataURIPrefix)
}

function isFileURI(filename) {
	return filename.startsWith("file://")
}
var wasmBinaryFile;
wasmBinaryFile = "NodePlayer.min.wasm";
if (!isDataURI(wasmBinaryFile)) {
	wasmBinaryFile = locateFile(wasmBinaryFile)
}

function getBinary(file) {
	try {
		if (file == wasmBinaryFile && wasmBinary) {
			return new Uint8Array(wasmBinary)
		}
		if (readBinary) {
			return readBinary(file)
		} else {
			throw "both async and sync fetching of the wasm failed"
		}
	} catch (err) {
		abort(err)
	}
}

function getBinaryPromise() {
	if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
		if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) {
			return fetch(wasmBinaryFile, {
				credentials: "same-origin"
			}).then(function(response) {
				if (!response["ok"]) {
					throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"
				}
				return response["arrayBuffer"]()
			}).catch(function() {
				return getBinary(wasmBinaryFile)
			})
		} else {
			if (readAsync) {
				return new Promise(function(resolve, reject) {
					readAsync(wasmBinaryFile, function(response) {
						resolve(new Uint8Array(response))
					}, reject)
				})
			}
		}
	}
	return Promise.resolve().then(function() {
		return getBinary(wasmBinaryFile)
	})
}

function createWasm() {
	var info = {
		"a": asmLibraryArg
	};

	function receiveInstance(instance, module) {
		var exports = instance.exports;
		Module["asm"] = exports;
		wasmMemory = Module["asm"]["ma"];
		updateGlobalBufferAndViews(wasmMemory.buffer);
		wasmTable = Module["asm"]["Ga"];
		addOnInit(Module["asm"]["na"]);
		removeRunDependency("wasm-instantiate")
	}
	addRunDependency("wasm-instantiate");

	function receiveInstantiationResult(result) {
		receiveInstance(result["instance"])
	}

	function instantiateArrayBuffer(receiver) {
		return getBinaryPromise().then(function(binary) {
			return WebAssembly.instantiate(binary, info)
		}).then(function(instance) {
			return instance
		}).then(receiver, function(reason) {
			err("failed to asynchronously prepare wasm: " + reason);
			abort(reason)
		})
	}

	function instantiateAsync() {
		if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
			return fetch(wasmBinaryFile, {
				credentials: "same-origin"
			}).then(function(response) {
				var result = WebAssembly.instantiateStreaming(response, info);
				return result.then(receiveInstantiationResult, function(reason) {
					err("wasm streaming compile failed: " + reason);
					err("falling back to ArrayBuffer instantiation");
					return instantiateArrayBuffer(receiveInstantiationResult)
				})
			})
		} else {
			return instantiateArrayBuffer(receiveInstantiationResult)
		}
	}
	if (Module["instantiateWasm"]) {
		try {
			var exports = Module["instantiateWasm"](info, receiveInstance);
			return exports
		} catch (e) {
			err("Module.instantiateWasm callback failed with error: " + e);
			return false
		}
	}
	instantiateAsync();
	return {}
}
var ASM_CONSTS = {
	211869: $0 => {
		var self = SL[$0];
		if (self && self.audioContext) {
			self.audioContext.resume()
		}
	},
	211955: $0 => {
		NP[$0] = {}
	},
	211972: $0 => {
		var self = NP[$0];
		if (self && self.ve && self.ve.getContext("webgl") && self.ve.getContext("webgl").getExtension("WEBGL_lose_context")) {
			self.ve.getContext("webgl").getExtension("WEBGL_lose_context").loseContext()
		}
	},
	212195: $0 => {
		var self = NP[$0];
		self.emit("buffer", "empty")
	},
	212248: ($0, $1, $2) => {
		var self = NP[$0];
		self.emit("metadata", new Uint8Array(Module.HEAPU8.buffer, $1, $2).slice(0, $2))
	},
	212353: () => {
		NP = {};
		if (typeof npAllReady == "function") {
			npAllReady()
		}
		window.npAllReadyFlag = true
	},
	212452: $0 => {
		var self = NP[$0];
		self.emit("buffer", "buffering")
	},
	212509: $0 => {
		var self = NP[$0];
		self.emit("buffer", "full")
	},
	212561: ($0, $1, $2, $3) => {
		var self = NP[$0];
		self.emit("videoSei", new Uint8Array(Module.HEAPU8.buffer, $1, $2), $3)
	},
	212657: ($0, $1, $2, $3) => {
		var self = NP[$0];
		self.emit("audioInfo", $1, $2, UTF8ToString($3))
	},
	212730: ($0, $1, $2, $3) => {
		var self = NP[$0];
		self.emit("videoInfo", $1, $2, UTF8ToString($3))
	},
	212803: ($0, $1) => {
		var self = NP[$0];
		self.emit("videoFrame", $1)
	},
	212855: $0 => {
		var self = NP[$0];
		self.emit("buffer", "empty")
	},
	212908: ($0, $1, $2, $3, $4, $5, $6) => {
		var self = NP[$0];
		self.emit("stats", {
			"buf": $1,
			"fps": $2,
			"abps": $3,
			"vbps": $4,
			"abuf": $5,
			"ts": $6
		})
	},
	213027: $0 => {
		if (typeof SL == "undefined") {
			SL = {}
		}
		SL[$0] = {};
		if (window.workletAudioEngine) {
			return 1024
		} else if (window.activeAudioEngine) {
			return 4800
		} else {
			return 4096
		}
	},
	213209: $0 => {
		if (typeof SL[$0] == "object") {
			delete SL[$0]
		}
	},
	213264: ($0, $1, $2, $3, $4) => {
		var AudioContext = window.webkitAudioContext || window.AudioContext;
		var sl = SL[$0];
		sl.audioContext = new AudioContext({
			sampleRate: 48e3
		});
		sl.gainNode = sl.audioContext.createGain();
		if (window.activeAudioEngine) {
			var interval = 1e3 * $1 / sl.audioContext.sampleRate;
			sl.startTime = 0;
			sl.timer = setInterval(function() {
				var ret = dynCall("ii", $3, [$0]);
				var audioSource = sl.audioContext.createBufferSource();
				var audioBuffer = sl.audioContext.createBuffer(1, $1, sl.audioContext.sampleRate);
				var channelData = audioBuffer.getChannelData(0);
				if (ret == $1) {
					channelData.set(Module.HEAPF32.subarray($4 >> 2, ($4 >> 2) + $1));
					if (sl.startTime < sl.audioContext.currentTime) {
						sl.startTime = sl.audioContext.currentTime
					}
					audioSource.buffer = audioBuffer;
					audioSource.connect(sl.gainNode);
					audioSource.start(sl.startTime);
					sl.startTime += audioBuffer.duration
				}
			}, interval)
		} else if (window.workletAudioEngine) {
			sl.audioContext.audioWorklet.addModule(NodePlayer.WAB()).then(() => {
				sl.workletProcessorNode = new AudioWorkletNode(sl.audioContext, "wa-processor", {
					outputChannelCount: [1]
				});
				sl.workletProcessorNode.connect(sl.gainNode);
				sl.workletProcessorNode.port.postMessage({
					"message": "init",
					"bufferSize": $1
				});
				sl.workletProcessorNode.port.onmessage = function(e) {
					if (sl.workletProcessorNode) {
						var ret = dynCall("ii", $3, [$0]);
						if (ret == $1) {
							var samples = new Float32Array(Module.HEAPU8.buffer, $4, $1).slice(0, $1);
							sl.workletProcessorNode.port.postMessage({
								"message": "data",
								"buffer": samples
							})
						} else {
							sl.workletProcessorNode.port.postMessage({
								"message": "zero"
							})
						}
					}
				}
			})
		} else {
			sl.scriptProcessorNode = sl.audioContext.createScriptProcessor($1, 0, $2);
			sl.scriptProcessorNode.onaudioprocess = function(e) {
				if (sl.audioContext) {
					var ret = dynCall("ii", $3, [$0]);
					var channelData = e.outputBuffer.getChannelData(0);
					if (channelData) {
						if (ret == $1) {
							channelData.set(Module.HEAPF32.subarray($4 >> 2, ($4 >> 2) + $1))
						} else {
							channelData.fill(0)
						}
					}
				}
			};
			sl.scriptProcessorNode.connect(sl.gainNode)
		}
		sl.gainNode.connect(sl.audioContext.destination);
		sl.audioContext.resume();
		return sl.audioContext.sampleRate
	},
	215413: $0 => {
		var sl = SL[$0];
		if (sl.gainNode != undefined) {
			sl.gainNode.disconnect();
			sl.gainNode = undefined
		}
		if (sl.scriptProcessorNode != undefined) {
			sl.scriptProcessorNode.disconnect();
			sl.scriptProcessorNode = undefined
		}
		if (sl.audioContext != undefined) {
			sl.audioContext.close();
			sl.audioContext = undefined
		}
		if (sl.timer != undefined) {
			clearInterval(sl.timer)
		}
		return 0
	},
	215795: ($0, $1) => {
		var sl = SL[$0];
		sl.gainNode.gain.value = $1
	}
};

function get_a_str() {
	var jsString = atob("VW5hdXRob3JpemVkIQ==");
	var lengthBytes = lengthBytesUTF8(jsString) + 1;
	var stringOnWasmHeap = _malloc(lengthBytes);
	stringToUTF8(jsString, stringOnWasmHeap, lengthBytes + 1);
	return stringOnWasmHeap
}

function get_audio_state(sl_render) {
	var self = SL[sl_render];
	return self && self.audioContext && self.audioContext.state == "suspended"
}

function get_do_str() {
	var jsString = document.domain;
	var lengthBytes = lengthBytesUTF8(jsString) + 1;
	var stringOnWasmHeap = _malloc(lengthBytes);
	stringToUTF8(jsString, stringOnWasmHeap, lengthBytes + 1);
	return stringOnWasmHeap
}

function get_e_str() {
	var jsString = atob("RW5kIG9mIHRoZSB0cmlhbCE=");
	var lengthBytes = lengthBytesUTF8(jsString) + 1;
	var stringOnWasmHeap = _malloc(lengthBytes);
	stringToUTF8(jsString, stringOnWasmHeap, lengthBytes + 1);
	return stringOnWasmHeap
}

function callRuntimeCallbacks(callbacks) {
	while (callbacks.length > 0) {
		var callback = callbacks.shift();
		if (typeof callback == "function") {
			callback(Module);
			continue
		}
		var func = callback.func;
		if (typeof func == "number") {
			if (callback.arg === undefined) {
				(function() {
					dynCall_v.call(null, func)
				})()
			} else {
				(function(a1) {
					dynCall_vi.apply(null, [func, a1])
				})(callback.arg)
			}
		} else {
			func(callback.arg === undefined ? null : callback.arg)
		}
	}
}

function dynCallLegacy(sig, ptr, args) {
	var f = Module["dynCall_" + sig];
	return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr)
}

function dynCall(sig, ptr, args) {
	return dynCallLegacy(sig, ptr, args)
}

function handleException(e) {
	if (e instanceof ExitStatus || e == "unwind") {
		return EXITSTATUS
	}
	quit_(1, e)
}
var SYSCALLS = {
	varargs: undefined,
	get: function() {
		SYSCALLS.varargs += 4;
		var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
		return ret
	},
	getStr: function(ptr) {
		var ret = UTF8ToString(ptr);
		return ret
	}
};

function ___syscall_fcntl64(fd, cmd, varargs) {
	SYSCALLS.varargs = varargs;
	return 0
}

function ___syscall_openat(dirfd, path, flags, varargs) {
	SYSCALLS.varargs = varargs
}

function __emscripten_date_now() {
	return Date.now()
}

function _abort() {
	abort("")
}
var readAsmConstArgsArray = [];

function readAsmConstArgs(sigPtr, buf) {
	readAsmConstArgsArray.length = 0;
	var ch;
	buf >>= 2;
	while (ch = HEAPU8[sigPtr++]) {
		buf += ch != 105 & buf;
		readAsmConstArgsArray.push(ch == 105 ? HEAP32[buf] : HEAPF64[buf++ >> 1]);
		++buf
	}
	return readAsmConstArgsArray
}

function _emscripten_asm_const_int(code, sigPtr, argbuf) {
	var args = readAsmConstArgs(sigPtr, argbuf);
	return ASM_CONSTS[code].apply(null, args)
}

function _emscripten_clear_interval(id) {
	clearInterval(id)
}
var JSEvents = {
	inEventHandler: 0,
	removeAllEventListeners: function() {
		for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
			JSEvents._removeHandler(i)
		}
		JSEvents.eventHandlers = [];
		JSEvents.deferredCalls = []
	},
	registerRemoveEventListeners: function() {
		if (!JSEvents.removeEventListenersRegistered) {
			__ATEXIT__.push(JSEvents.removeAllEventListeners);
			JSEvents.removeEventListenersRegistered = true
		}
	},
	deferredCalls: [],
	deferCall: function(targetFunction, precedence, argsList) {
		function arraysHaveEqualContent(arrA, arrB) {
			if (arrA.length != arrB.length) return false;
			for (var i in arrA) {
				if (arrA[i] != arrB[i]) return false
			}
			return true
		}
		for (var i in JSEvents.deferredCalls) {
			var call = JSEvents.deferredCalls[i];
			if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
				return
			}
		}
		JSEvents.deferredCalls.push({
			targetFunction: targetFunction,
			precedence: precedence,
			argsList: argsList
		});
		JSEvents.deferredCalls.sort(function(x, y) {
			return x.precedence < y.precedence
		})
	},
	removeDeferredCalls: function(targetFunction) {
		for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
			if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
				JSEvents.deferredCalls.splice(i, 1);
				--i
			}
		}
	},
	canPerformEventHandlerRequests: function() {
		return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls
	},
	runDeferredCalls: function() {
		if (!JSEvents.canPerformEventHandlerRequests()) {
			return
		}
		for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
			var call = JSEvents.deferredCalls[i];
			JSEvents.deferredCalls.splice(i, 1);
			--i;
			call.targetFunction.apply(null, call.argsList)
		}
	},
	eventHandlers: [],
	removeAllHandlersOnTarget: function(target, eventTypeString) {
		for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
			if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
				JSEvents._removeHandler(i--)
			}
		}
	},
	_removeHandler: function(i) {
		var h = JSEvents.eventHandlers[i];
		h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
		JSEvents.eventHandlers.splice(i, 1)
	},
	registerOrRemoveHandler: function(eventHandler) {
		var jsEventHandler = function jsEventHandler(event) {
			++JSEvents.inEventHandler;
			JSEvents.currentEventHandler = eventHandler;
			JSEvents.runDeferredCalls();
			eventHandler.handlerFunc(event);
			JSEvents.runDeferredCalls();
			--JSEvents.inEventHandler
		};
		if (eventHandler.callbackfunc) {
			eventHandler.eventListenerFunc = jsEventHandler;
			eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
			JSEvents.eventHandlers.push(eventHandler);
			JSEvents.registerRemoveEventListeners()
		} else {
			for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
				if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
					JSEvents._removeHandler(i--)
				}
			}
		}
	},
	getNodeNameForTarget: function(target) {
		if (!target) return "";
		if (target == window) return "#window";
		if (target == screen) return "#screen";
		return target && target.nodeName ? target.nodeName : ""
	},
	fullscreenEnabled: function() {
		return document.fullscreenEnabled || document.webkitFullscreenEnabled
	}
};

function maybeCStringToJsString(cString) {
	return cString > 2 ? UTF8ToString(cString) : cString
}
var specialHTMLTargets = [0, typeof document != "undefined" ? document : 0, typeof window != "undefined" ? window : 0];

function findEventTarget(target) {
	target = maybeCStringToJsString(target);
	var domElement = specialHTMLTargets[target] || (typeof document != "undefined" ? document.querySelector(target) : undefined);
	return domElement
}

function findCanvasEventTarget(target) {
	return findEventTarget(target)
}

function _emscripten_get_canvas_element_size(target, width, height) {
	var canvas = findCanvasEventTarget(target);
	if (!canvas) return -4;
	HEAP32[width >> 2] = canvas.width;
	HEAP32[height >> 2] = canvas.height
}

function getBoundingClientRect(e) {
	return specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {
		"left": 0,
		"top": 0
	}
}

function _emscripten_get_element_css_size(target, width, height) {
	target = findEventTarget(target);
	if (!target) return -4;
	var rect = getBoundingClientRect(target);
	HEAPF64[width >> 3] = rect.width;
	HEAPF64[height >> 3] = rect.height;
	return 0
}

function getHeapMax() {
	return 2147483648
}

function _emscripten_get_heap_max() {
	return getHeapMax()
}

function _emscripten_memcpy_big(dest, src, num) {
	HEAPU8.copyWithin(dest, src, src + num)
}

function emscripten_realloc_buffer(size) {
	try {
		wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
		updateGlobalBufferAndViews(wasmMemory.buffer);
		return 1
	} catch (e) {}
}

function _emscripten_resize_heap(requestedSize) {
	var oldSize = HEAPU8.length;
	requestedSize = requestedSize >>> 0;
	var maxHeapSize = getHeapMax();
	if (requestedSize > maxHeapSize) {
		return false
	}
	let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
	for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
		var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
		overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
		var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
		var replacement = emscripten_realloc_buffer(newSize);
		if (replacement) {
			return true
		}
	}
	return false
}

function _emscripten_set_canvas_element_size(target, width, height) {
	var canvas = findCanvasEventTarget(target);
	if (!canvas) return -4;
	canvas.width = width;
	canvas.height = height;
	return 0
}

function _emscripten_set_element_css_size(target, width, height) {
	target = findEventTarget(target);
	if (!target) return -4;
	target.style.width = width + "px";
	target.style.height = height + "px";
	return 0
}

function callUserCallback(func, synchronous) {
	if (ABORT) {
		return
	}
	if (synchronous) {
		func();
		return
	}
	try {
		func()
	} catch (e) {
		handleException(e)
	}
}

function _emscripten_set_interval(cb, msecs, userData) {
	return setInterval(function() {
		callUserCallback(function() {
			(function(a1) {
				dynCall_vi.apply(null, [cb, a1])
			})(userData)
		})
	}, msecs)
}

function registerKeyEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
	if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc(176);
	var keyEventHandlerFunc = function(e) {
		var keyEventData = JSEvents.keyEvent;
		HEAPF64[keyEventData >> 3] = e.timeStamp;
		var idx = keyEventData >> 2;
		HEAP32[idx + 2] = e.location;
		HEAP32[idx + 3] = e.ctrlKey;
		HEAP32[idx + 4] = e.shiftKey;
		HEAP32[idx + 5] = e.altKey;
		HEAP32[idx + 6] = e.metaKey;
		HEAP32[idx + 7] = e.repeat;
		HEAP32[idx + 8] = e.charCode;
		HEAP32[idx + 9] = e.keyCode;
		HEAP32[idx + 10] = e.which;
		stringToUTF8(e.key || "", keyEventData + 44, 32);
		stringToUTF8(e.code || "", keyEventData + 76, 32);
		stringToUTF8(e.char || "", keyEventData + 108, 32);
		stringToUTF8(e.locale || "", keyEventData + 140, 32);
		if (function(a1, a2, a3) {
				return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3])
			}(eventTypeId, keyEventData, userData)) e.preventDefault()
	};
	var eventHandler = {
		target: findEventTarget(target),
		allowsDeferredCalls: true,
		eventTypeString: eventTypeString,
		callbackfunc: callbackfunc,
		handlerFunc: keyEventHandlerFunc,
		useCapture: useCapture
	};
	JSEvents.registerOrRemoveHandler(eventHandler)
}

function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
	registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
	return 0
}

function fillMouseEventData(eventStruct, e, target) {
	HEAPF64[eventStruct >> 3] = e.timeStamp;
	var idx = eventStruct >> 2;
	HEAP32[idx + 2] = e.screenX;
	HEAP32[idx + 3] = e.screenY;
	HEAP32[idx + 4] = e.clientX;
	HEAP32[idx + 5] = e.clientY;
	HEAP32[idx + 6] = e.ctrlKey;
	HEAP32[idx + 7] = e.shiftKey;
	HEAP32[idx + 8] = e.altKey;
	HEAP32[idx + 9] = e.metaKey;
	HEAP16[idx * 2 + 20] = e.button;
	HEAP16[idx * 2 + 21] = e.buttons;
	HEAP32[idx + 11] = e["movementX"];
	HEAP32[idx + 12] = e["movementY"];
	var rect = getBoundingClientRect(target);
	HEAP32[idx + 13] = e.clientX - rect.left;
	HEAP32[idx + 14] = e.clientY - rect.top
}

function registerMouseEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
	if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc(72);
	target = findEventTarget(target);
	var mouseEventHandlerFunc = function(ev) {
		var e = ev || event;
		fillMouseEventData(JSEvents.mouseEvent, e, target);
		if (function(a1, a2, a3) {
				return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3])
			}(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault()
	};
	var eventHandler = {
		target: target,
		allowsDeferredCalls: eventTypeString != "mousemove" && eventTypeString != "mouseenter" && eventTypeString != "mouseleave",
		eventTypeString: eventTypeString,
		callbackfunc: callbackfunc,
		handlerFunc: mouseEventHandlerFunc,
		useCapture: useCapture
	};
	JSEvents.registerOrRemoveHandler(eventHandler)
}

function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
	registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
	return 0
}

function registerTouchEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
	if (!JSEvents.touchEvent) JSEvents.touchEvent = _malloc(1696);
	target = findEventTarget(target);
	var touchEventHandlerFunc = function(e) {
		var t, touches = {},
			et = e.touches;
		for (var i = 0; i < et.length; ++i) {
			t = et[i];
			t.isChanged = t.onTarget = 0;
			touches[t.identifier] = t
		}
		for (var i = 0; i < e.changedTouches.length; ++i) {
			t = e.changedTouches[i];
			t.isChanged = 1;
			touches[t.identifier] = t
		}
		for (var i = 0; i < e.targetTouches.length; ++i) {
			touches[e.targetTouches[i].identifier].onTarget = 1
		}
		var touchEvent = JSEvents.touchEvent;
		HEAPF64[touchEvent >> 3] = e.timeStamp;
		var idx = touchEvent >> 2;
		HEAP32[idx + 3] = e.ctrlKey;
		HEAP32[idx + 4] = e.shiftKey;
		HEAP32[idx + 5] = e.altKey;
		HEAP32[idx + 6] = e.metaKey;
		idx += 7;
		var targetRect = getBoundingClientRect(target);
		var numTouches = 0;
		for (var i in touches) {
			t = touches[i];
			HEAP32[idx + 0] = t.identifier;
			HEAP32[idx + 1] = t.screenX;
			HEAP32[idx + 2] = t.screenY;
			HEAP32[idx + 3] = t.clientX;
			HEAP32[idx + 4] = t.clientY;
			HEAP32[idx + 5] = t.pageX;
			HEAP32[idx + 6] = t.pageY;
			HEAP32[idx + 7] = t.isChanged;
			HEAP32[idx + 8] = t.onTarget;
			HEAP32[idx + 9] = t.clientX - targetRect.left;
			HEAP32[idx + 10] = t.clientY - targetRect.top;
			idx += 13;
			if (++numTouches > 31) {
				break
			}
		}
		HEAP32[touchEvent + 8 >> 2] = numTouches;
		if (function(a1, a2, a3) {
				return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3])
			}(eventTypeId, touchEvent, userData)) e.preventDefault()
	};
	var eventHandler = {
		target: target,
		allowsDeferredCalls: eventTypeString == "touchstart" || eventTypeString == "touchend",
		eventTypeString: eventTypeString,
		callbackfunc: callbackfunc,
		handlerFunc: touchEventHandlerFunc,
		useCapture: useCapture
	};
	JSEvents.registerOrRemoveHandler(eventHandler)
}

function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
	registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
	return 0
}

function __webgl_enable_ANGLE_instanced_arrays(ctx) {
	var ext = ctx.getExtension("ANGLE_instanced_arrays");
	if (ext) {
		ctx["vertexAttribDivisor"] = function(index, divisor) {
			ext["vertexAttribDivisorANGLE"](index, divisor)
		};
		ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
			ext["drawArraysInstancedANGLE"](mode, first, count, primcount)
		};
		ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
			ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount)
		};
		return 1
	}
}

function __webgl_enable_OES_vertex_array_object(ctx) {
	var ext = ctx.getExtension("OES_vertex_array_object");
	if (ext) {
		ctx["createVertexArray"] = function() {
			return ext["createVertexArrayOES"]()
		};
		ctx["deleteVertexArray"] = function(vao) {
			ext["deleteVertexArrayOES"](vao)
		};
		ctx["bindVertexArray"] = function(vao) {
			ext["bindVertexArrayOES"](vao)
		};
		ctx["isVertexArray"] = function(vao) {
			return ext["isVertexArrayOES"](vao)
		};
		return 1
	}
}

function __webgl_enable_WEBGL_draw_buffers(ctx) {
	var ext = ctx.getExtension("WEBGL_draw_buffers");
	if (ext) {
		ctx["drawBuffers"] = function(n, bufs) {
			ext["drawBuffersWEBGL"](n, bufs)
		};
		return 1
	}
}

function __webgl_enable_WEBGL_multi_draw(ctx) {
	return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"))
}
var GL = {
	counter: 1,
	buffers: [],
	programs: [],
	framebuffers: [],
	renderbuffers: [],
	textures: [],
	shaders: [],
	vaos: [],
	contexts: [],
	offscreenCanvases: {},
	queries: [],
	stringCache: {},
	unpackAlignment: 4,
	recordError: function recordError(errorCode) {
		if (!GL.lastError) {
			GL.lastError = errorCode
		}
	},
	getNewId: function(table) {
		var ret = GL.counter++;
		for (var i = table.length; i < ret; i++) {
			table[i] = null
		}
		return ret
	},
	getSource: function(shader, count, string, length) {
		var source = "";
		for (var i = 0; i < count; ++i) {
			var len = length ? HEAP32[length + i * 4 >> 2] : -1;
			source += UTF8ToString(HEAP32[string + i * 4 >> 2], len < 0 ? undefined : len)
		}
		return source
	},
	createContext: function(canvas, webGLContextAttributes) {
		if (!canvas.getContextSafariWebGL2Fixed) {
			canvas.getContextSafariWebGL2Fixed = canvas.getContext;

			function fixedGetContext(ver, attrs) {
				var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
				return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null
			}
			canvas.getContext = fixedGetContext
		}
		var ctx = canvas.getContext("webgl", webGLContextAttributes);
		if (!ctx) return 0;
		var handle = GL.registerContext(ctx, webGLContextAttributes);
		return handle
	},
	registerContext: function(ctx, webGLContextAttributes) {
		var handle = GL.getNewId(GL.contexts);
		var context = {
			handle: handle,
			attributes: webGLContextAttributes,
			version: webGLContextAttributes.majorVersion,
			GLctx: ctx
		};
		if (ctx.canvas) ctx.canvas.GLctxObject = context;
		GL.contexts[handle] = context;
		if (typeof webGLContextAttributes.enableExtensionsByDefault == "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
			GL.initExtensions(context)
		}
		return handle
	},
	makeContextCurrent: function(contextHandle) {
		GL.currentContext = GL.contexts[contextHandle];
		Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
		return !(contextHandle && !GLctx)
	},
	getContext: function(contextHandle) {
		return GL.contexts[contextHandle]
	},
	deleteContext: function(contextHandle) {
		if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
		if (typeof JSEvents == "object") JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
		if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined;
		GL.contexts[contextHandle] = null
	},
	initExtensions: function(context) {
		if (!context) context = GL.currentContext;
		if (context.initExtensionsDone) return;
		context.initExtensionsDone = true;
		var GLctx = context.GLctx;
		__webgl_enable_ANGLE_instanced_arrays(GLctx);
		__webgl_enable_OES_vertex_array_object(GLctx);
		__webgl_enable_WEBGL_draw_buffers(GLctx); {
			GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query")
		}
		__webgl_enable_WEBGL_multi_draw(GLctx);
		var exts = GLctx.getSupportedExtensions() || [];
		exts.forEach(function(ext) {
			if (!ext.includes("lose_context") && !ext.includes("debug")) {
				GLctx.getExtension(ext)
			}
		})
	}
};
var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];

function _emscripten_webgl_do_create_context(target, attributes) {
	var a = attributes >> 2;
	var powerPreference = HEAP32[a + (24 >> 2)];
	var contextAttributes = {
		"alpha": !!HEAP32[a + (0 >> 2)],
		"depth": !!HEAP32[a + (4 >> 2)],
		"stencil": !!HEAP32[a + (8 >> 2)],
		"antialias": !!HEAP32[a + (12 >> 2)],
		"premultipliedAlpha": !!HEAP32[a + (16 >> 2)],
		"preserveDrawingBuffer": !!HEAP32[a + (20 >> 2)],
		"powerPreference": __emscripten_webgl_power_preferences[powerPreference],
		"failIfMajorPerformanceCaveat": !!HEAP32[a + (28 >> 2)],
		majorVersion: HEAP32[a + (32 >> 2)],
		minorVersion: HEAP32[a + (36 >> 2)],
		enableExtensionsByDefault: HEAP32[a + (40 >> 2)],
		explicitSwapControl: HEAP32[a + (44 >> 2)],
		proxyContextToMainThread: HEAP32[a + (48 >> 2)],
		renderViaOffscreenBackBuffer: HEAP32[a + (52 >> 2)]
	};
	var canvas = findCanvasEventTarget(target);
	if (!canvas) {
		return 0
	}
	if (contextAttributes.explicitSwapControl) {
		return 0
	}
	var contextHandle = GL.createContext(canvas, contextAttributes);
	return contextHandle
}

function _emscripten_webgl_create_context(a0, a1) {
	return _emscripten_webgl_do_create_context(a0, a1)
}

function _emscripten_webgl_destroy_context(contextHandle) {
	if (GL.currentContext == contextHandle) GL.currentContext = 0;
	GL.deleteContext(contextHandle)
}

function _emscripten_webgl_init_context_attributes(attributes) {
	var a = attributes >> 2;
	for (var i = 0; i < 56 >> 2; ++i) {
		HEAP32[a + i] = 0
	}
	HEAP32[a + (0 >> 2)] = HEAP32[a + (4 >> 2)] = HEAP32[a + (12 >> 2)] = HEAP32[a + (16 >> 2)] = HEAP32[a + (32 >> 2)] = HEAP32[a + (40 >> 2)] = 1
}

function _emscripten_webgl_make_context_current(contextHandle) {
	var success = GL.makeContextCurrent(contextHandle);
	return success ? 0 : -5
}
var ENV = {};

function getExecutableName() {
	return thisProgram || "./this.program"
}

function getEnvStrings() {
	if (!getEnvStrings.strings) {
		var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
		var env = {
			"USER": "web_user",
			"LOGNAME": "web_user",
			"PATH": "/",
			"PWD": "/",
			"HOME": "/home/web_user",
			"LANG": lang,
			"_": getExecutableName()
		};
		for (var x in ENV) {
			if (ENV[x] === undefined) delete env[x];
			else env[x] = ENV[x]
		}
		var strings = [];
		for (var x in env) {
			strings.push(x + "=" + env[x])
		}
		getEnvStrings.strings = strings
	}
	return getEnvStrings.strings
}

function _environ_get(__environ, environ_buf) {
	var bufSize = 0;
	getEnvStrings().forEach(function(string, i) {
		var ptr = environ_buf + bufSize;
		HEAPU32[__environ + i * 4 >> 2] = ptr;
		writeAsciiToMemory(string, ptr);
		bufSize += string.length + 1
	});
	return 0
}

function _environ_sizes_get(penviron_count, penviron_buf_size) {
	var strings = getEnvStrings();
	HEAPU32[penviron_count >> 2] = strings.length;
	var bufSize = 0;
	strings.forEach(function(string) {
		bufSize += string.length + 1
	});
	HEAPU32[penviron_buf_size >> 2] = bufSize;
	return 0
}

function _fd_close(fd) {
	return 52
}

function _fd_fdstat_get(fd, pbuf) {
	var type = fd == 1 || fd == 2 ? 2 : abort();
	HEAP8[pbuf >> 0] = type;
	return 0
}

function _fd_read(fd, iov, iovcnt, pnum) {
	return 52
}

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
	return 70
}
var printCharBuffers = [null, [],
	[]
];

function printChar(stream, curr) {
	var buffer = printCharBuffers[stream];
	if (curr === 0 || curr === 10) {
		(stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
		buffer.length = 0
	} else {
		buffer.push(curr)
	}
}

function _fd_write(fd, iov, iovcnt, pnum) {
	var num = 0;
	for (var i = 0; i < iovcnt; i++) {
		var ptr = HEAPU32[iov >> 2];
		var len = HEAPU32[iov + 4 >> 2];
		iov += 8;
		for (var j = 0; j < len; j++) {
			printChar(fd, HEAPU8[ptr + j])
		}
		num += len
	}
	HEAPU32[pnum >> 2] = num;
	return 0
}

function _glActiveTexture(x0) {
	GLctx["activeTexture"](x0)
}

function _glAttachShader(program, shader) {
	GLctx.attachShader(GL.programs[program], GL.shaders[shader])
}

function _glBindBuffer(target, buffer) {
	GLctx.bindBuffer(target, GL.buffers[buffer])
}

function _glBindTexture(target, texture) {
	GLctx.bindTexture(target, GL.textures[texture])
}

function _glBufferData(target, size, data, usage) {
	GLctx.bufferData(target, data ? HEAPU8.subarray(data, data + size) : size, usage)
}

function _glClear(x0) {
	GLctx["clear"](x0)
}

function _glClearColor(x0, x1, x2, x3) {
	GLctx["clearColor"](x0, x1, x2, x3)
}

function _glCompileShader(shader) {
	GLctx.compileShader(GL.shaders[shader])
}

function _glCreateProgram() {
	var id = GL.getNewId(GL.programs);
	var program = GLctx.createProgram();
	program.name = id;
	program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
	program.uniformIdCounter = 1;
	GL.programs[id] = program;
	return id
}

function _glCreateShader(shaderType) {
	var id = GL.getNewId(GL.shaders);
	GL.shaders[id] = GLctx.createShader(shaderType);
	return id
}

function _glDeleteProgram(id) {
	if (!id) return;
	var program = GL.programs[id];
	if (!program) {
		GL.recordError(1281);
		return
	}
	GLctx.deleteProgram(program);
	program.name = 0;
	GL.programs[id] = null
}

function _glDeleteShader(id) {
	if (!id) return;
	var shader = GL.shaders[id];
	if (!shader) {
		GL.recordError(1281);
		return
	}
	GLctx.deleteShader(shader);
	GL.shaders[id] = null
}

function _glDeleteTextures(n, textures) {
	for (var i = 0; i < n; i++) {
		var id = HEAP32[textures + i * 4 >> 2];
		var texture = GL.textures[id];
		if (!texture) continue;
		GLctx.deleteTexture(texture);
		texture.name = 0;
		GL.textures[id] = null
	}
}

function _glDrawArrays(mode, first, count) {
	GLctx.drawArrays(mode, first, count)
}

function _glEnableVertexAttribArray(index) {
	GLctx.enableVertexAttribArray(index)
}

function __glGenObject(n, buffers, createFunction, objectTable) {
	for (var i = 0; i < n; i++) {
		var buffer = GLctx[createFunction]();
		var id = buffer && GL.getNewId(objectTable);
		if (buffer) {
			buffer.name = id;
			objectTable[id] = buffer
		} else {
			GL.recordError(1282)
		}
		HEAP32[buffers + i * 4 >> 2] = id
	}
}

function _glGenBuffers(n, buffers) {
	__glGenObject(n, buffers, "createBuffer", GL.buffers)
}

function _glGenTextures(n, textures) {
	__glGenObject(n, textures, "createTexture", GL.textures)
}

function _glGetAttribLocation(program, name) {
	return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name))
}

function _glGetError() {
	var error = GLctx.getError() || GL.lastError;
	GL.lastError = 0;
	return error
}

function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
	var log = GLctx.getProgramInfoLog(GL.programs[program]);
	if (log === null) log = "(unknown error)";
	var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
	if (length) HEAP32[length >> 2] = numBytesWrittenExclNull
}

function _glGetProgramiv(program, pname, p) {
	if (!p) {
		GL.recordError(1281);
		return
	}
	if (program >= GL.counter) {
		GL.recordError(1281);
		return
	}
	program = GL.programs[program];
	if (pname == 35716) {
		var log = GLctx.getProgramInfoLog(program);
		if (log === null) log = "(unknown error)";
		HEAP32[p >> 2] = log.length + 1
	} else if (pname == 35719) {
		if (!program.maxUniformLength) {
			for (var i = 0; i < GLctx.getProgramParameter(program, 35718); ++i) {
				program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i).name.length + 1)
			}
		}
		HEAP32[p >> 2] = program.maxUniformLength
	} else if (pname == 35722) {
		if (!program.maxAttributeLength) {
			for (var i = 0; i < GLctx.getProgramParameter(program, 35721); ++i) {
				program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i).name.length + 1)
			}
		}
		HEAP32[p >> 2] = program.maxAttributeLength
	} else if (pname == 35381) {
		if (!program.maxUniformBlockNameLength) {
			for (var i = 0; i < GLctx.getProgramParameter(program, 35382); ++i) {
				program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i).length + 1)
			}
		}
		HEAP32[p >> 2] = program.maxUniformBlockNameLength
	} else {
		HEAP32[p >> 2] = GLctx.getProgramParameter(program, pname)
	}
}

function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
	var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
	if (log === null) log = "(unknown error)";
	var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
	if (length) HEAP32[length >> 2] = numBytesWrittenExclNull
}

function _glGetShaderiv(shader, pname, p) {
	if (!p) {
		GL.recordError(1281);
		return
	}
	if (pname == 35716) {
		var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
		if (log === null) log = "(unknown error)";
		var logLength = log ? log.length + 1 : 0;
		HEAP32[p >> 2] = logLength
	} else if (pname == 35720) {
		var source = GLctx.getShaderSource(GL.shaders[shader]);
		var sourceLength = source ? source.length + 1 : 0;
		HEAP32[p >> 2] = sourceLength
	} else {
		HEAP32[p >> 2] = GLctx.getShaderParameter(GL.shaders[shader], pname)
	}
}

function jstoi_q(str) {
	return parseInt(str)
}

function webglGetLeftBracePos(name) {
	return name.slice(-1) == "]" && name.lastIndexOf("[")
}

function webglPrepareUniformLocationsBeforeFirstUse(program) {
	var uniformLocsById = program.uniformLocsById,
		uniformSizeAndIdsByName = program.uniformSizeAndIdsByName,
		i, j;
	if (!uniformLocsById) {
		program.uniformLocsById = uniformLocsById = {};
		program.uniformArrayNamesById = {};
		for (i = 0; i < GLctx.getProgramParameter(program, 35718); ++i) {
			var u = GLctx.getActiveUniform(program, i);
			var nm = u.name;
			var sz = u.size;
			var lb = webglGetLeftBracePos(nm);
			var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
			var id = program.uniformIdCounter;
			program.uniformIdCounter += sz;
			uniformSizeAndIdsByName[arrayName] = [sz, id];
			for (j = 0; j < sz; ++j) {
				uniformLocsById[id] = j;
				program.uniformArrayNamesById[id++] = arrayName
			}
		}
	}
}

function _glGetUniformLocation(program, name) {
	name = UTF8ToString(name);
	if (program = GL.programs[program]) {
		webglPrepareUniformLocationsBeforeFirstUse(program);
		var uniformLocsById = program.uniformLocsById;
		var arrayIndex = 0;
		var uniformBaseName = name;
		var leftBrace = webglGetLeftBracePos(name);
		if (leftBrace > 0) {
			arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0;
			uniformBaseName = name.slice(0, leftBrace)
		}
		var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];
		if (sizeAndId && arrayIndex < sizeAndId[0]) {
			arrayIndex += sizeAndId[1];
			if (uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name)) {
				return arrayIndex
			}
		}
	} else {
		GL.recordError(1281)
	}
	return -1
}

function _glLinkProgram(program) {
	program = GL.programs[program];
	GLctx.linkProgram(program);
	program.uniformLocsById = 0;
	program.uniformSizeAndIdsByName = {}
}

function _glPixelStorei(pname, param) {
	if (pname == 3317) {
		GL.unpackAlignment = param
	}
	GLctx.pixelStorei(pname, param)
}

function _glShaderSource(shader, count, string, length) {
	var source = GL.getSource(shader, count, string, length);
	GLctx.shaderSource(GL.shaders[shader], source)
}

function computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
	function roundedToNextMultipleOf(x, y) {
		return x + y - 1 & -y
	}
	var plainRowSize = width * sizePerPixel;
	var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
	return height * alignedRowSize
}

function __colorChannelsInGlTextureFormat(format) {
	var colorChannels = {
		5: 3,
		6: 4,
		8: 2,
		29502: 3,
		29504: 4
	};
	return colorChannels[format - 6402] || 1
}

function heapObjectForWebGLType(type) {
	type -= 5120;
	if (type == 1) return HEAPU8;
	if (type == 4) return HEAP32;
	if (type == 6) return HEAPF32;
	if (type == 5 || type == 28922) return HEAPU32;
	return HEAPU16
}

function heapAccessShiftForWebGLHeap(heap) {
	return 31 - Math.clz32(heap.BYTES_PER_ELEMENT)
}

function emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) {
	var heap = heapObjectForWebGLType(type);
	var shift = heapAccessShiftForWebGLHeap(heap);
	var byteSize = 1 << shift;
	var sizePerPixel = __colorChannelsInGlTextureFormat(format) * byteSize;
	var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
	return heap.subarray(pixels >> shift, pixels + bytes >> shift)
}

function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
	GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null)
}

function _glTexParameterf(x0, x1, x2) {
	GLctx["texParameterf"](x0, x1, x2)
}

function webglGetUniformLocation(location) {
	var p = GLctx.currentProgram;
	if (p) {
		var webglLoc = p.uniformLocsById[location];
		if (typeof webglLoc == "number") {
			p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? "[" + webglLoc + "]" : ""))
		}
		return webglLoc
	} else {
		GL.recordError(1282)
	}
}

function _glUniform1i(location, v0) {
	GLctx.uniform1i(webglGetUniformLocation(location), v0)
}

function _glUseProgram(program) {
	program = GL.programs[program];
	GLctx.useProgram(program);
	GLctx.currentProgram = program
}

function _glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
	GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr)
}

function _glViewport(x0, x1, x2, x3) {
	GLctx["viewport"](x0, x1, x2, x3)
}

function _setTempRet0(val) {
	setTempRet0(val)
}
var GLctx;
var asmLibraryArg = {
	"P": ___syscall_fcntl64,
	"J": ___syscall_openat,
	"i": __emscripten_date_now,
	"a": _abort,
	"b": _emscripten_asm_const_int,
	"n": _emscripten_clear_interval,
	"D": _emscripten_get_canvas_element_size,
	"E": _emscripten_get_element_css_size,
	"I": _emscripten_get_heap_max,
	"N": _emscripten_memcpy_big,
	"H": _emscripten_resize_heap,
	"d": _emscripten_set_canvas_element_size,
	"ga": _emscripten_set_element_css_size,
	"o": _emscripten_set_interval,
	"F": _emscripten_set_keydown_callback_on_thread,
	"ka": _emscripten_set_mousedown_callback_on_thread,
	"ja": _emscripten_set_touchstart_callback_on_thread,
	"ha": _emscripten_webgl_create_context,
	"p": _emscripten_webgl_destroy_context,
	"ia": _emscripten_webgl_init_context_attributes,
	"c": _emscripten_webgl_make_context_current,
	"L": _environ_get,
	"M": _environ_sizes_get,
	"r": _fd_close,
	"K": _fd_fdstat_get,
	"O": _fd_read,
	"G": _fd_seek,
	"q": _fd_write,
	"fa": get_a_str,
	"V": get_audio_state,
	"la": get_do_str,
	"_": get_e_str,
	"g": _glActiveTexture,
	"t": _glAttachShader,
	"x": _glBindBuffer,
	"f": _glBindTexture,
	"w": _glBufferData,
	"B": _glClear,
	"C": _glClearColor,
	"ba": _glCompileShader,
	"T": _glCreateProgram,
	"da": _glCreateShader,
	"Q": _glDeleteProgram,
	"m": _glDeleteShader,
	"Z": _glDeleteTextures,
	"X": _glDrawArrays,
	"u": _glEnableVertexAttribArray,
	"$": _glGenBuffers,
	"W": _glGenTextures,
	"y": _glGetAttribLocation,
	"ea": _glGetError,
	"R": _glGetProgramInfoLog,
	"s": _glGetProgramiv,
	"aa": _glGetShaderInfoLog,
	"A": _glGetShaderiv,
	"l": _glGetUniformLocation,
	"S": _glLinkProgram,
	"U": _glPixelStorei,
	"ca": _glShaderSource,
	"j": _glTexImage2D,
	"e": _glTexParameterf,
	"k": _glUniform1i,
	"z": _glUseProgram,
	"v": _glVertexAttribPointer,
	"Y": _glViewport,
	"h": _setTempRet0
};
var asm = createWasm();
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
	return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["na"]).apply(null, arguments)
};
var _ng = Module["_ng"] = function() {
	return (_ng = Module["_ng"] = Module["asm"]["oa"]).apply(null, arguments)
};
var _nc = Module["_nc"] = function() {
	return (_nc = Module["_nc"] = Module["asm"]["pa"]).apply(null, arguments)
};
var _nd = Module["_nd"] = function() {
	return (_nd = Module["_nd"] = Module["asm"]["qa"]).apply(null, arguments)
};
var _ns = Module["_ns"] = function() {
	return (_ns = Module["_ns"] = Module["asm"]["ra"]).apply(null, arguments)
};
var _np = Module["_np"] = function() {
	return (_np = Module["_np"] = Module["asm"]["sa"]).apply(null, arguments)
};
var _nv = Module["_nv"] = function() {
	return (_nv = Module["_nv"] = Module["asm"]["ta"]).apply(null, arguments)
};
var _nr = Module["_nr"] = function() {
	return (_nr = Module["_nr"] = Module["asm"]["ua"]).apply(null, arguments)
};
var _ni = Module["_ni"] = function() {
	return (_ni = Module["_ni"] = Module["asm"]["va"]).apply(null, arguments)
};
var _nm = Module["_nm"] = function() {
	return (_nm = Module["_nm"] = Module["asm"]["wa"]).apply(null, arguments)
};
var _nb = Module["_nb"] = function() {
	return (_nb = Module["_nb"] = Module["asm"]["xa"]).apply(null, arguments)
};
var _nk = Module["_nk"] = function() {
	return (_nk = Module["_nk"] = Module["asm"]["ya"]).apply(null, arguments)
};
var _ne = Module["_ne"] = function() {
	return (_ne = Module["_ne"] = Module["asm"]["za"]).apply(null, arguments)
};
var _ny = Module["_ny"] = function() {
	return (_ny = Module["_ny"] = Module["asm"]["Aa"]).apply(null, arguments)
};
var _nar = Module["_nar"] = function() {
	return (_nar = Module["_nar"] = Module["asm"]["Ba"]).apply(null, arguments)
};
var _nor = Module["_nor"] = function() {
	return (_nor = Module["_nor"] = Module["asm"]["Ca"]).apply(null, arguments)
};
var _nse = Module["_nse"] = function() {
	return (_nse = Module["_nse"] = Module["asm"]["Da"]).apply(null, arguments)
};
var _ncv = Module["_ncv"] = function() {
	return (_ncv = Module["_ncv"] = Module["asm"]["Ea"]).apply(null, arguments)
};
var _main = Module["_main"] = function() {
	return (_main = Module["_main"] = Module["asm"]["Fa"]).apply(null, arguments)
};
var _malloc = Module["_malloc"] = function() {
	return (_malloc = Module["_malloc"] = Module["asm"]["Ha"]).apply(null, arguments)
};
var stackSave = Module["stackSave"] = function() {
	return (stackSave = Module["stackSave"] = Module["asm"]["Ia"]).apply(null, arguments)
};
var stackRestore = Module["stackRestore"] = function() {
	return (stackRestore = Module["stackRestore"] = Module["asm"]["Ja"]).apply(null, arguments)
};
var stackAlloc = Module["stackAlloc"] = function() {
	return (stackAlloc = Module["stackAlloc"] = Module["asm"]["Ka"]).apply(null, arguments)
};
var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function() {
	return (dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = Module["asm"]["La"]).apply(null, arguments)
};
var dynCall_iiii = Module["dynCall_iiii"] = function() {
	return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["Ma"]).apply(null, arguments)
};
var dynCall_vi = Module["dynCall_vi"] = function() {
	return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["Na"]).apply(null, arguments)
};
var dynCall_ii = Module["dynCall_ii"] = function() {
	return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["Oa"]).apply(null, arguments)
};
var dynCall_vii = Module["dynCall_vii"] = function() {
	return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["Pa"]).apply(null, arguments)
};
var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
	return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["Qa"]).apply(null, arguments)
};
var dynCall_viiii = Module["dynCall_viiii"] = function() {
	return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["Ra"]).apply(null, arguments)
};
var dynCall_v = Module["dynCall_v"] = function() {
	return (dynCall_v = Module["dynCall_v"] = Module["asm"]["Sa"]).apply(null, arguments)
};
var dynCall_dd = Module["dynCall_dd"] = function() {
	return (dynCall_dd = Module["dynCall_dd"] = Module["asm"]["Ta"]).apply(null, arguments)
};
var dynCall_iii = Module["dynCall_iii"] = function() {
	return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["Ua"]).apply(null, arguments)
};
var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
	return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["Va"]).apply(null, arguments)
};
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
	return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["Wa"]).apply(null, arguments)
};
var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
	return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["Xa"]).apply(null, arguments)
};
var dynCall_viii = Module["dynCall_viii"] = function() {
	return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["Ya"]).apply(null, arguments)
};
var dynCall_viifi = Module["dynCall_viifi"] = function() {
	return (dynCall_viifi = Module["dynCall_viifi"] = Module["asm"]["Za"]).apply(null, arguments)
};
var dynCall_fiii = Module["dynCall_fiii"] = function() {
	return (dynCall_fiii = Module["dynCall_fiii"] = Module["asm"]["_a"]).apply(null, arguments)
};
var dynCall_viidi = Module["dynCall_viidi"] = function() {
	return (dynCall_viidi = Module["dynCall_viidi"] = Module["asm"]["$a"]).apply(null, arguments)
};
var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
	return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["ab"]).apply(null, arguments)
};
var dynCall_viiiifii = Module["dynCall_viiiifii"] = function() {
	return (dynCall_viiiifii = Module["dynCall_viiiifii"] = Module["asm"]["bb"]).apply(null, arguments)
};
var dynCall_fii = Module["dynCall_fii"] = function() {
	return (dynCall_fii = Module["dynCall_fii"] = Module["asm"]["cb"]).apply(null, arguments)
};
var dynCall_viiiiiifi = Module["dynCall_viiiiiifi"] = function() {
	return (dynCall_viiiiiifi = Module["dynCall_viiiiiifi"] = Module["asm"]["db"]).apply(null, arguments)
};
var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = function() {
	return (dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = Module["asm"]["eb"]).apply(null, arguments)
};
var dynCall_viiiiiiiiii = Module["dynCall_viiiiiiiiii"] = function() {
	return (dynCall_viiiiiiiiii = Module["dynCall_viiiiiiiiii"] = Module["asm"]["fb"]).apply(null, arguments)
};
var dynCall_viiiiiiii = Module["dynCall_viiiiiiii"] = function() {
	return (dynCall_viiiiiiii = Module["dynCall_viiiiiiii"] = Module["asm"]["gb"]).apply(null, arguments)
};
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
	return (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = Module["asm"]["hb"]).apply(null, arguments)
};
var dynCall_viiijj = Module["dynCall_viiijj"] = function() {
	return (dynCall_viiijj = Module["dynCall_viiijj"] = Module["asm"]["ib"]).apply(null, arguments)
};
var dynCall_iiiiiiidiiddii = Module["dynCall_iiiiiiidiiddii"] = function() {
	return (dynCall_iiiiiiidiiddii = Module["dynCall_iiiiiiidiiddii"] = Module["asm"]["jb"]).apply(null, arguments)
};
var dynCall_jij = Module["dynCall_jij"] = function() {
	return (dynCall_jij = Module["dynCall_jij"] = Module["asm"]["kb"]).apply(null, arguments)
};
var dynCall_jii = Module["dynCall_jii"] = function() {
	return (dynCall_jii = Module["dynCall_jii"] = Module["asm"]["lb"]).apply(null, arguments)
};
var dynCall_jiji = Module["dynCall_jiji"] = function() {
	return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["mb"]).apply(null, arguments)
};
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
	return (dynCall_iidiiii = Module["dynCall_iidiiii"] = Module["asm"]["xa"]).apply(null, arguments)
};
var _ff_h264_cabac_tables = Module["_ff_h264_cabac_tables"] = 153662;
var calledRun;

function ExitStatus(status) {
	this.name = "ExitStatus";
	this.message = "Program terminated with exit(" + status + ")";
	this.status = status
}
var calledMain = false;
dependenciesFulfilled = function runCaller() {
	if (!calledRun) run();
	if (!calledRun) dependenciesFulfilled = runCaller
};

function callMain(args) {
	var entryFunction = Module["_main"];
	var argc = 0;
	var argv = 0;
	try {
		var ret = entryFunction(argc, argv);
		exit(ret, true);
		return ret
	} catch (e) {
		return handleException(e)
	} finally {
		calledMain = true
	}
}

function run(args) {
	args = args || arguments_;
	if (runDependencies > 0) {
		return
	}
	preRun();
	if (runDependencies > 0) {
		return
	}

	function doRun() {
		if (calledRun) return;
		calledRun = true;
		Module["calledRun"] = true;
		if (ABORT) return;
		initRuntime();
		preMain();
		if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
		if (shouldRunNow) callMain(args);
		postRun()
	}
	if (Module["setStatus"]) {
		Module["setStatus"]("Running...");
		setTimeout(function() {
			setTimeout(function() {
				Module["setStatus"]("")
			}, 1);
			doRun()
		}, 1)
	} else {
		doRun()
	}
}
Module["run"] = run;

function exit(status, implicit) {
	EXITSTATUS = status;
	procExit(status)
}

function procExit(code) {
	EXITSTATUS = code;
	if (!keepRuntimeAlive()) {
		if (Module["onExit"]) Module["onExit"](code);
		ABORT = true
	}
	quit_(code, new ExitStatus(code))
}
if (Module["preInit"]) {
	if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
	while (Module["preInit"].length > 0) {
		Module["preInit"].pop()()
	}
}
var shouldRunNow = true;
if (Module["noInitialRun"]) shouldRunNow = false;
run();
var NodePlayer = function() {
	null;
	const D = {
		nc: cwrap("nc", "number", ["number"]),
		nd: cwrap("nd", "number", ["number"]),
		ns: cwrap("ns", "number", ["number", "string"]),
		np: cwrap("np", "number", ["number"]),
		ni: cwrap("ni", "number", ["number", "array", "number"]),
		ng: cwrap("ng", "string"),
		nv: cwrap("nv", "number", ["number", "string", "number"]),
		nm: cwrap("nm", "number", ["number", "number"]),
		nb: cwrap("nb", "number", ["number", "number"]),
		nk: cwrap("nk", "number", ["number", "number"]),
		ne: cwrap("ne", "number", ["number", "number"]),
		nr: cwrap("nr", "number", ["number", "number", "number", "number"]),
		ny: cwrap("ny", "number", ["number", "string"]),
		nor: cwrap("nor", "number", ["number", "number", "number"]),
		nar: cwrap("nar", "number", ["number"]),
		nse: cwrap("nse", "number", ["number", "number"]),
		ncv: cwrap("ncv", "number", ["number"])
	};
	document.addEventListener("fullscreenchange", a => {
		a.target.ctx && (document.fullscreenElement ? a.target.offsetHeight > 0 && a.target.offsetHeight > 0 && D.nr(a.target.ctx, a.target.offsetWidth, a.target.offsetHeight, 1) : D.nr(a.target.ctx, a.target.tw, a.target.th, 1))
	});
	class Z extends y {
		constructor() {
			super();
			this.ism = /(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent) ? 1 : 0, this.ctx = D.nc(this.ism), this.dpr = window.devicePixelRatio || 1, this.rpr = screen.width / document.documentElement.clientWidth * this.dpr, this.version = D.ng(), this.isStart = !1, this.isMSE = !1, this.hasAudio = !0, this.volume = 1, this.eventFlags = 0, this.screenCount = 0, this.connTimeout = 0, this.connTimer = null, this.screenshotImage1 = null, this.screenshotImage2 = null, this.headers = {}, this.loader = new Te, this.loader.on("data", e => {
				let t = D.ni(this.ctx, e, e.length);
				t < 0 && (this.emit("error", "input data error, " + t), this.stop())
			}), this.loader.on("open", () => {
				this.emit("start")
			}), this.loader.on("close", () => {
				this.stop()
			}), this.loader.on("error", e => {
				this.emit("error", e), this.stop()
			}), NP[this.ctx].emit = this.emit.bind(this), this.on("buffer", e => {
				this.connTimeout > 0 && (this._clearTimeout(), e === "empty" && (this.connTimer = setTimeout(() => {
					this.emit("timeout")
				}, this.connTimeout * 1e3)))
			}), this.ism && (this.wakeLock = new Oe)
		}
		on(e, t) {
			super.on(e, t), e === "videoSei" ? this.eventFlags |= 1 : e === "videoFrame" && (this.eventFlags |= 2), D.nse(this.ctx, this.eventFlags)
		}
		setTimeout(e) {
			e > 0 ? this.connTimeout = e : this._clearTimeout()
		}
		_clearTimeout() {
			this.connTimer != null && (clearTimeout(this.connTimer), this.connTimer = null)
		}
		addHeaders(e) {
			this.headers = e
		}
		setView(e) {
			if (this.isMSE) {
				let t = document.getElementById(e),
					i = document.createElement("video"),
					s = t.parentNode;
				i.id = e, t.width != 300 && t.height != 150 && (i.width = t.width, i.height = t.height), i.style.cssText = t.style.cssText, s.replaceChild(i, t), this.ve = i
			} else return this.ve = document.getElementById(e), this.ve.ctx = this.ctx, NP[this.ctx].ve = this.ve, D.nv(this.ctx, "#" + e, this.dpr, this.rpr)
		}
		resizeView(e, t) {
			this.isMSE || D.nr(this.ctx, e, t, 0)
		}
		setKeepScreenOn() {
			this.isKeepOn = !0
		}
		setScaleMode(e) {
			return D.nm(this.ctx, e)
		}
		setBufferTime(e) {
			return D.nb(this.ctx, e)
		}
		skipLoopFilter(e) {
			return D.nk(this.ctx, e)
		}
		setVolume(e) {
			this.volume = e, this.isMSE ? this.flvPlayer && (this.flvPlayer.volume = e) : D.ne(this.ctx, e)
		}
		setCryptoKey(e) {
			D.ny(this.ctx, e)
		}
		enableAudio(e) {
			this.hasAudio = e, e || (this.volume = 0)
		}
		audioResume() {
			D.nar(this.ctx)
		}
		launchIntoFullscreen(e) {
			e.requestFullscreen ? e.requestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen()
		}
		fullscreen() {
			this.ve.tw = this.ve.width, this.ve.th = this.ve.height, this.launchIntoFullscreen(this.ve)
		}
		fullWebview(e) {
			this.ve.tmpcss = this.ve.style.cssText, this.ve.style.cssText = "width:100%;height:100%;position:absolute;top: 0;left: 0;z-index: -1;", D.nor(this.ctx, e)
		}
		exitFullWebview() {
			this.ve.tmpcss === void 0 || this.ve.tmpcss === "" || (this.ve.style.cssText = this.ve.tmpcss, D.nor(this.ctx, 0))
		}
		onResize(e, t) {
			D.nor(this.ctx, e, t)
		}
		screenshot(e, t, i) {
			if (this.isStart && this.screenCount++ < 30) {
				if (this.screenshotImage1 == null) {
					this.screenshotImage1 = this.ve.toDataURL("image/" + t, i), setTimeout(() => {
						this.screenshot(e, t, i)
					}, 100);
					return
				}
				if (this.screenshotImage2 == null && (this.screenshotImage2 = this.ve.toDataURL("image/" + t, i)), this.screenshotImage1.length === this.screenshotImage2.length) {
					this.screenshotImage2 = null, setTimeout(() => {
						this.screenshot(e, t, i)
					}, 100);
					return
				}
				var s = document.createElement("a");
				s.href = this.screenshotImage1.length > this.screenshotImage2.length ? this.screenshotImage1 : this.screenshotImage2, s.download = e, s.click(), this.screenCount = 0, this.screenshotImage1 = null, this.screenshotImage2 = null
			} else this.screenCount = 0, this.screenshotImage1 = null, this.screenshotImage2 = null, this.emit("error", "screenshot error")
		}
		start(e) {
			if (this.isMSE) {
				if (this.flvPlayer) return;
				let t = {
					type: "flv",
					url: e
				};
				this.hasAudio || (t.hasAudio = !1), this.flvPlayer = Ke(t), this.flvPlayer.attachMediaElement(this.ve), this.flvPlayer.on(v.ERROR, i => {
					this.emit("error", i), this.stop()
				}), this.flvPlayer.on(v.LOADING_COMPLETE, () => {
					this.stop()
				}), this.flvPlayer.on(v.MEDIA_INFO, () => {
					this.isStart || (this.isStart = !0, this.emit("start"))
				}), this.flvPlayer.load(), this.flvPlayer.play().catch(i => {})
			} else {
				if (typeof e != "string") {
					NP_ERROR("url invalid parameter");
					return
				}
				if (this.isStart) {
					NP_DEBUG("The instance has started, ignore it");
					return
				}
				NP_INFO("call start play url:", e), this.url = e, this.ism && this.isKeepOn && this.wakeLock.enable(), D.ns(this.ctx, e) == 0 && (this.setVolume(this.volume), this.loader.start(e, this.headers), this.isStart = !0)
			}
		}
		stop() {
			if (this.isMSE) this.flvPlayer && (this.flvPlayer.detachMediaElement(), this.flvPlayer.unload(), this.flvPlayer.destroy(), this.flvPlayer = null, this.emit("stop"), this.isStart = !1);
			else {
				if (!this.isStart) {
					NP_DEBUG("The instance has not started yet, ignore it");
					return
				}
				NP_INFO("call stop play url:", this.url), this.ism && this.isKeepOn && this.wakeLock.disable(), this.isStart = !1, this.loader.stop(), this._clearTimeout(), D.np(this.ctx), this.emit("stop")
			}
		}
		clearView() {
			D.ncv(this.ctx)
		}
		release(e) {
			this.isMSE || (this.stop(), D.nd(this.ctx, e)), delete NP[this.ctx], this.ctx = null, this.loader = null, this.wakeLock = null
		}
		useMSE() {
			this.isMSE = Je(), NP_INFO("use MSE:", this.isMSE ? "YES" : "NO"), this.isMSE && (this.flvPlayer = null, O.enableAll = !1, O.addLogListener(function(e, t) {
				NP_INFO(e + t)
			}))
		}
		static activeAudioEngine(e) {
			window.activeAudioEngine = e, e && NP_INFO("NodePlayer.js use activeAudioEngine")
		}
		static workletAudioEngine(e) {
			window.workletAudioEngine = e & Xe(), window.workletAudioEngine && NP_INFO("NodePlayer.js use workletAudioEngine")
		}
		static debug(e) {
			e ? Module.logLevel = NP_LOGLEVEL.INFO : Module.logLevel = NP_LOGLEVEL.NONE
		}
		static load(e) {
			window.npAllReadyFlag ? e() : setTimeout(Z.load.bind(this, e), 100)
		}
		static asyncLoad() {
			return new Promise((e, t) => {
				Z.load(() => {
					e()
				})
			})
		}
	}
	class ve {
		async start(e, t) {
			this.isStart = !0, this.fetchAbortController = new AbortController;
			try {
				let i = this.fetchAbortController.signal,
					s = await fetch(e, {
						signal: i,
						headers: t
					});
				if (!s.ok) {
					this.isStart = !1, this.emit("error", {
						code: -2,
						msg: "open url error, status code is " + s.status
					});
					return
				}
				this.emit("open");
				let r = s.body.getReader();
				for (; this.isStart;) {
					let n = await r.read();
					if (n.done) {
						this.emit("close");
						break
					}
					this.emit("data", n.value)
				}
			} catch (i) {
				this.fetchAbortController && this.emit("error", {
					code: -3,
					msg: i.message
				})
			}
			this.isStart = !1
		}
		stop() {
			this.isStart = !1, this.fetchAbortController && (this.fetchAbortController.abort(), this.fetchAbortController = null)
		}
		postMessage() {}
		send() {}
	}

	function Le() {
		class a {
			async start(i) {
				this.isStart = !0, this.fetchAbortController = new AbortController;
				try {
					let s = this.fetchAbortController.signal,
						r = {};
					Object.assign(r, i.headers);
					let n = await fetch(i.url, {
						signal: s,
						headers: r
					});
					if (!n.ok) {
						this.isStart = !1, self.postMessage({
							func: "error",
							arg: {
								code: -2,
								msg: "open url error, status code is " + n.status
							}
						});
						return
					}
					self.postMessage({
						func: "open"
					});
					let A = n.body.getReader();
					for (; this.isStart;) {
						let h = await A.read();
						if (h.done) {
							self.postMessage({
								func: "close"
							});
							break
						}
						self.postMessage({
							func: "data",
							arg: h.value
						})
					}
				} catch (s) {
					this.fetchAbortController && self.postMessage({
						func: "error",
						arg: {
							code: -3,
							msg: s.message
						}
					})
				}
				this.isStart = !1
			}
			stop() {
				this.isStart = !1, this.fetchAbortController && (this.fetchAbortController.abort(), this.fetchAbortController = null)
			}
			send(i) {}
		}
		const e = new a;
		onmessage = t => {
			const {
				func: i,
				arg: s
			} = t.data;
			switch (i) {
				case "start":
					e.start(s);
					break;
				case "stop":
					e.stop();
					break;
				case "send":
					e.send(s);
					break
			}
		}
	}
	class De {
		constructor() {
			this.inBytes = 0, this.outBytes = 0, this.socket = null
		}
		start(e) {
			this.url = e.replace(/^rtmp:|^rtsp:/, "ws:"), this.url === e && (this.url = e.replace(/^rtmps:/, "wss:")), this.socket = new WebSocket(this.url), this.socket.binaryType = "arraybuffer", this.socket.onopen = () => {
				this.emit("open")
			}, this.socket.onclose = () => {
				this.emit("close")
			}, this.socket.onerror = t => {
				this.emit("error", {
					code: -3,
					msg: t
				})
			}, this.socket.onmessage = t => {
				try {
					const i = new Uint8Array(t.data);
					this.inBytes += i.length, this.emit("data", i)
				} catch (i) {
					this.emit("error", {
						code: -2,
						msg: i.message
					})
				}
			}
		}
		postMessage() {}
		stop() {
			this.inBytes = 0, this.outBytes = 0, this.socket.close(), this.socket = null
		}
		send(e) {
			this.outBytes += e.byteLength, this.socket.send(e)
		}
	}
	class Te extends y {
		constructor() {
			super();
			this.loader = null
		}
		getFuncBody(e) {
			return e.trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1]
		}
		checkResponse() {
			return typeof window.ReadableStream == "function" && typeof window.Response == "function"
		}
		checkResponseBody() {
			return Object.prototype.hasOwnProperty.call(window.Response.prototype, "body")
		}
		start(e, t) {
			if (this.loader == null)
				if (/^ws{1,2}:|^rtmp:|^rtmps:|^rtsp:/i.test(e)) this.loader = new De, this.loader.emit = this.emit.bind(this), this.loader.terminate = this.loader.stop, this.loader.start(e);
				else if (this.checkResponse() && this.checkResponseBody()) this.loader = new ve, this.loader.emit = this.emit.bind(this), this.loader.terminate = this.loader.stop, this.loader.start(e, t);
			else if (this.checkResponse()) {
				const i = this.getFuncBody(Le.toString()),
					s = new Blob([i], {
						type: "text/javascript"
					});
				this.workerURL = URL.createObjectURL(s), this.loader = new Worker(this.workerURL), this.loader.onmessage = r => {
					const {
						func: n,
						arg: A
					} = r.data;
					this.emit(n, A)
				}, this.loader.postMessage({
					func: "start",
					arg: {
						url: e,
						headers: t
					}
				})
			} else this.emit("error", {
				code: -4,
				msg: "No loader is available."
			});
			else this.emit("error", {
				code: -1,
				msg: "StreamLoader has started."
			})
		}
		stop() {
			this.loader != null ? (this.loader.postMessage({
				func: "stop"
			}), this.loader.terminate(), this.loader = null) : this.emit("error", {
				code: -1,
				msg: "StreamLoader has not been started yet."
			})
		}
		send(e) {
			this.loader.send(e)
		}
	}
	const Fe = "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACORtZGF03gIATGF2YzU4LjM1LjEwMAACMEAOAAACcQYF//9t3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2MSByMzAyNyA0MTIxMjc3IC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTAgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTcgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0wIHdlaWdodHA9MCBrZXlpbnQ9MjUwIGtleWludF9taW49MTAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIzLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IGlwX3JhdGlvPTEuNDAgYXE9MToxLjAwAIAAAADvZYiED/JigADD7JycnJycnJycnJycnJycnJycnJ11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111114BGCAHARggBwEYIAcBGCAHARggBwAAAAdBmjgf4BLYARggBwEYIAcBGCAHARggBwAAAAdBmlQH+AS2ARggBwEYIAcBGCAHARggBwAAAAdBmmA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZqAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZqgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZrAP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0Ga4D/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbAD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbID/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBm0A/wCWwARggBwEYIAcBGCAHAAAAB0GbYD/AJbABGCAHARggBwEYIAcAAAAHQZuAP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GboD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbwD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0Gb4D/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBmgA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmiA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmkA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZpgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZqAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZqgP8AlsAEYIAcBGCAHARggBwAAAAdBmsA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmuA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmwA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZsgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZtAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZtgP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GbgD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GboD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GbwD/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBm+A/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmgA/wCWwARggBwEYIAcAAAAHQZogP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GaQD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GaYD/AJbABGCAHARggBwEYIAcBGCAHAAAAB0GagD/AJbABGCAHARggBwEYIAcBGCAHARggBwAAAAdBmqA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmsA/wCWwARggBwEYIAcBGCAHARggBwAAAAdBmuA/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZsAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZsgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZtAP8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GbYD/AJbABGCAHARggBwAAAAdBm4A/wCWwARggBwEYIAcBGCAHARggBwAAAAdBm6A/wCWwARggBwEYIAcBGCAHARggBwEYIAcAAAAHQZvAP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZvgP8AlsAEYIAcBGCAHARggBwEYIAcAAAAHQZoAO8AlsAEYIAcBGCAHARggBwEYIAcBGCAHAAAAB0GaIDfAJbABGCAHARggBwEYIAcBGCAHAAAMxm1vb3YAAABsbXZoZAAAAAAAAAAAAAAAAAAAA+gAABOgAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAPLdHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAQAAAAAAABOIAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAElVVUA8AAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAATiAAAAAAAAQAAAAADQ21kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAAKAAAAMgAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAu5taW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAKuc3RibAAAAKpzdHNkAAAAAAAAAAEAAACaYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAFAAPAASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADRhdmNDAULAC//hABxnQsAL2QFB+/8ACwAMEAAAAwAQAAADAUDxQqSAAQAFaMuDyyAAAAAQcGFzcAAAAAsAAAAMAAAAGHN0dHMAAAAAAAAAAQAAADIAAAQAAAAAFHN0c3MAAAAAAAAAAQAAAAEAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAA3HN0c3oAAAAAAAAAAAAAADIAAANoAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAAAsAAAALAAAACwAAANhzdGNvAAAAAAAAADIAAABFAAADwQAAA9wAAAP3AAAEFgAABDEAAARMAAAEawAABIYAAAShAAAEwAAABNcAAATuAAAFDQAABSgAAAVDAAAFYgAABX0AAAWYAAAFtwAABdIAAAXtAAAGBAAABh8AAAY6AAAGWQAABnQAAAaPAAAGrgAABskAAAbkAAAHAwAABx4AAAcxAAAHUAAAB2sAAAeGAAAHpQAAB8AAAAfbAAAH+gAACBUAAAgwAAAITwAACGIAAAh9AAAInAAACLcAAAjSAAAI8QAACCV0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAAE6AAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAABOIAAAEAAABAAAAAAedbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAACsRAADYVRVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAAHSG1pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAHDHN0YmwAAABqc3RzZAAAAAAAAAABAAAAWm1wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAACsRAAAAAAANmVzZHMAAAAAA4CAgCUAAgAEgICAF0AVAAAAAAENiAAABVQFgICABRIIVuUABoCAgAECAAAAYHN0dHMAAAAAAAAACgAAAC8AAAQAAAAAAQAACtUAAAAsAAAEAAAAAAEAAArWAAAALAAABAAAAAABAAAK1QAAACwAAAQAAAAAAQAACtUAAAAaAAAEAAAAAAEAAAH/AAABzHN0c2MAAAAAAAAAJQAAAAEAAAABAAAAAQAAAAIAAAAFAAAAAQAAAAMAAAAEAAAAAQAAAAUAAAAFAAAAAQAAAAYAAAAEAAAAAQAAAAgAAAAFAAAAAQAAAAkAAAAEAAAAAQAAAAsAAAAFAAAAAQAAAAwAAAADAAAAAQAAAA4AAAAFAAAAAQAAAA8AAAAEAAAAAQAAABEAAAAFAAAAAQAAABIAAAAEAAAAAQAAABQAAAAFAAAAAQAAABUAAAAEAAAAAQAAABcAAAADAAAAAQAAABgAAAAEAAAAAQAAABoAAAAFAAAAAQAAABsAAAAEAAAAAQAAAB0AAAAFAAAAAQAAAB4AAAAEAAAAAQAAACAAAAAFAAAAAQAAACEAAAAEAAAAAQAAACIAAAACAAAAAQAAACMAAAAFAAAAAQAAACQAAAAEAAAAAQAAACYAAAAFAAAAAQAAACcAAAAEAAAAAQAAACkAAAAFAAAAAQAAACoAAAAEAAAAAQAAACwAAAAFAAAAAQAAAC0AAAACAAAAAQAAAC4AAAAEAAAAAQAAAC8AAAAFAAAAAQAAADAAAAAEAAAAAQAAADIAAAAFAAAAAQAAADMAAAAEAAAAAQAAA1xzdHN6AAAAAAAAAAAAAADSAAAAFQAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAA3HN0Y28AAAAAAAAAMwAAADAAAAOtAAADzAAAA+cAAAQCAAAEIQAABDwAAARXAAAEdgAABJEAAASsAAAEywAABOIAAAT5AAAFGAAABTMAAAVOAAAFbQAABYgAAAWjAAAFwgAABd0AAAX4AAAGDwAABioAAAZFAAAGZAAABn8AAAaaAAAGuQAABtQAAAbvAAAHDgAABykAAAc8AAAHWwAAB3YAAAeRAAAHsAAAB8sAAAfmAAAIBQAACCAAAAg7AAAIWgAACG0AAAiIAAAIpwAACMIAAAjdAAAI/AAAABpzZ3BkAQAAAHJvbGwAAAACAAAAAf//AAAAHHNiZ3AAAAAAcm9sbAAAAAEAAADSAAAAAQAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTguMjAuMTAw",
		ke = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwEAAAAAABLfEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHYTbuMU6uEElTDZ1OsggGXTbuMU6uEHFO7a1OsghLJ7AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmsirXsYMPQkBNgI1MYXZmNTguNDUuMTAwV0GNTGF2ZjU4LjQ1LjEwMESJiECzmgAAAAAAFlSua0C5rgEAAAAAAABO14EBc8WI9UhIq9EDJPCcgQAitZyDdW5khoVWX1ZQOIOBASPjg4QF9eEA4AEAAAAAAAAbsIIBQLqB8FSwggElVLqB8FWwiFW3gQFVuIECrgEAAAAAAABZ14ECc8WIUEWPA9J/iJ6cgQAitZyDdW5khoZBX09QVVNWqoNjLqBWu4QExLQAg4EC4ZGfgQG1iEDncAAAAAAAYmSBIGOik09wdXNIZWFkAQE4AYC7AAAAAAASVMNnQcJzcwEAAAAAAACXY8CAZ8gBAAAAAAAAFUWji01BSk9SX0JSQU5ERIeEaXNvbWfIAQAAAAAAABZFo41NSU5PUl9WRVJTSU9ORIeDNTEyZ8gBAAAAAAAAJ0WjkUNPTVBBVElCTEVfQlJBTkRTRIeQaXNvbWlzbzJhdmMxbXA0MWfIAQAAAAAAABpFo4dFTkNPREVSRIeNTGF2ZjU4LjQ1LjEwMHNzAQAAAAAAAIZjwItjxYj1SEir0QMk8GfIAQAAAAAAAB5Fo4xIQU5ETEVSX05BTUVEh4xWaWRlb0hhbmRsZXJnyAEAAAAAAAAhRaOHRU5DT0RFUkSHlExhdmM1OC45MS4xMDAgbGlidnB4Z8iiRaOIRFVSQVRJT05Eh5QwMDowMDowNS4wMDcwMDAwMDAAAHNzAQAAAAAAAIdjwItjxYhQRY8D0n+InmfIAQAAAAAAAB5Fo4xIQU5ETEVSX05BTUVEh4xTb3VuZEhhbmRsZXJnyAEAAAAAAAAiRaOHRU5DT0RFUkSHlUxhdmM1OC45MS4xMDAgbGlib3B1c2fIokWjiERVUkFUSU9ORIeUMDA6MDA6MDUuMDE4MDAwMDAwAAAfQ7Z1T2TngQCjh4IAAID4//6jQKSBAAeAMBIAnQEqQAHwAABHCIWFiIWEiAICAAYWBPcGgWSfa9ubJzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh7Jzh69AD+/6tQgKOHggAVgPj//qOHggApgPj//qOHggA9gPj//qOHggBRgPj//qOHggBlgPj//qOegQBrANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCAHmA+P/+o4eCAI2A+P/+o4eCAKGA+P/+o4eCALWA+P/+o4eCAMmA+P/+o56BAM8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IA3YD4//6jh4IA8YD4//6jh4IBBYD4//6jh4IBGYD4//6jh4IBLYD4//6jnoEBMwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggFBgPj//qOHggFVgPj//qOHggFpgPj//qOHggF9gPj//qOHggGRgPj//qOegQGXANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCAaWA+P/+o4eCAbmA+P/+o4eCAc2A+P/+o4eCAeGA+P/+o4eCAfWA+P/+o56BAfsA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4ICCYD4//6jh4ICHYD4//6jh4ICMYD4//6jh4ICRYD4//6jh4ICWYD4//6jnoECXwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggJtgPj//qOHggKBgPj//qOHggKVgPj//qOHggKpgPj//qOHggK9gPj//qOegQLDANECAAUQEBRgAGFgv9AAIgAQzX61yT5xzAAAo4eCAtGA+P/+o4eCAuWA+P/+o4eCAvmA+P/+o4eCAw2A+P/+o4eCAyGA+P/+o56BAycA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IDNYD4//6jh4IDSYD4//6jh4IDXYD4//6jh4IDcYD4//6jh4IDhYD4//6jnoEDiwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggOZgPj//qOHggOtgPj//qOHggPBgPj//qOHggPVgPj//qOHggPpgPj//qOegQPvANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCA/2A+P/+o4eCBBGA+P/+o4eCBCWA+P/+o4eCBDmA+P/+o4eCBE2A+P/+o56BBFMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IEiID4//6jh4IEnID4//6jh4IEsID4//6jnoEEtwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggTEgPj//qOHggTYgPj//qOHggTsgPj//qOHggUAgPj//qOHggUUgPj//qOegQUbANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCBSiA+P/+o4eCBTyA+P/+o4eCBVCA+P/+o4eCBWSA+P/+o4eCBXiA+P/+o56BBX8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IFjID4//6jh4IFoID4//6jh4IFtID4//6jh4IFyID4//6jh4IF3ID4//6jnoEF4wDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggXwgPj//qOHggYEgPj//qOHggYYgPj//qOHggYsgPj//qOHggZAgPj//qOegQZHANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCBlSA+P/+o4eCBmiA+P/+o4eCBnyA+P/+o4eCBpCA+P/+o4eCBqSA+P/+o56BBqsA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IGuID4//6jh4IGzID4//6jh4IG4ID4//6jh4IG9ID4//6jh4IHCID4//6jnoEHDwDRAgAFEBAUYABhYL/QACIAEM1+tck+ccwAAKOHggccgPj//qOHggcwgPj//qOHggdEgPj//qOHggdYgPj//qOHggdsgPj//qOegQdzANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCB4CA+P/+o4eCB5SA+P/+o4eCB6iA+P/+o4eCB7yA+P/+o4eCB9CA+P/+o56BB9cA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IH5ID4//6jh4IH+ID4//6jh4IIDID4//6jh4IIIID4//6jh4IINID4//6jnoEIOwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgghIgPj//qOHgghcgPj//qOHgghwgPj//qOHggiEgPj//qOegQifANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCCMCA+P/+o4eCCNSA+P/+o4eCCOiA+P/+o4eCCPyA+P/+o56BCQMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IJEID4//6jh4IJJID4//6jh4IJOID4//6jh4IJTID4//6jh4IJYID4//6jnoEJZwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggl0gPj//qOHggmIgPj//qOHggmcgPj//qOHggmwgPj//qOHggnEgPj//qOegQnLANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCCdiA+P/+o4eCCeyA+P/+o4eCCgCA+P/+o4eCChSA+P/+o4eCCiiA+P/+o56BCi8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IKPID4//6jh4IKUID4//6jh4IKZID4//6jh4IKeID4//6jh4IKjID4//6jnoEKkwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggqggPj//qOHggq0gPj//qOHggrIgPj//qOHggrcgPj//qOHggrwgPj//qOegQr3ANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCCwSA+P/+o4eCCxiA+P/+o4eCCyyA+P/+o4eCC0CA+P/+o4eCC1SA+P/+o56BC1sA0QIABRAQFGAAYWC/0AAiABDNfrXJPnHMAACjh4ILaID4//6jh4ILfID4//6jh4ILkID4//6jh4ILpID4//6jh4ILuID4//6jnoELvwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHggvMgPj//qOHggvggPj//qOHggv0gPj//qOHggwIgPj//qOHggwcgPj//qOegQwjANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCDDCA+P/+o4eCDESA+P/+o4eCDFiA+P/+o4eCDGyA+P/+o4eCDICA+P/+o56BDIcA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IMlID4//6jh4IMqID4//6jh4IMvID4//6jh4IM0ID4//6jnoEM6wDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgg0MgPj//qOHgg0ggPj//qOHgg00gPj//qOHgg1IgPj//qOegQ1PANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCDVyA+P/+o4eCDXCA+P/+o4eCDYSA+P/+o4eCDZiA+P/+o4eCDayA+P/+o56BDbMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4INwID4//6jh4IN1ID4//6jh4IN6ID4//6jh4IN/ID4//6jh4IOEID4//6jnoEOFwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgg4kgPj//qOHgg44gPj//qOHgg5MgPj//qOHgg5ggPj//qOHgg50gPj//qOegQ57ANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCDoiA+P/+o4eCDpyA+P/+o4eCDrCA+P/+o4eCDsSA+P/+o4eCDtiA+P/+o56BDt8A0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IO7ID4//6jh4IPAID4//6jh4IPFID4//6jh4IPKID4//6jh4IPPID4//6jnoEPQwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHgg9QgPj//qOHgg9kgPj//qOHgg94gPj//qOHgg+MgPj//qOHgg+ggPj//qOegQ+nANECAAUQEBRgAGFgv9AAIgAQzX61yT5xzAAAo4eCD7SA+P/+o4eCD8iA+P/+o4eCD9yA+P/+o4eCD/CA+P/+o4eCEASA+P/+o56BEAsA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IQGID4//6jh4IQLID4//6jh4IQQID4//6jh4IQVID4//6jh4IQaID4//6jnoEQbwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHghB8gPj//qOHghCQgPj//qOHghCkgPj//qOHghC4gPj//qOHghDMgPj//qOegRDTANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCEOCA+P/+o4eCEPSA+P/+o4eCEQiA+P/+o56BETcA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4IRQ4D4//6jh4IRV4D4//6jh4IRa4D4//6jh4IRf4D4//6jh4IRk4D4//6jnoERmwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHghGngPj//qOHghG7gPj//qOHghHPgPj//qOHghHjgPj//qOHghH3gPj//qOegRH/ANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCEguA+P/+o4eCEh+A+P/+o4eCEjOA+P/+o4eCEkeA+P/+o4eCEluA+P/+o56BEmMA0QIABRCsABgAGFgv9AAIgAQzX61yT5xzAACjh4ISb4D4//6jh4ISg4D4//6jh4ISl4D4//6jh4ISq4D4//6jh4ISv4D4//6jnoESxwDRAgAFEKwAGAAYWC/0AAiABDNfrXJPnHMAAKOHghLTgPj//qOHghLngPj//qOHghL7gPj//qOHghMPgPj//qOHghMjgPj//qOegRMrANECAAUQrAAYABhYL/QACIAEM1+tck+ccwAAo4eCEzeA+P/+o4eCE0uA+P/+o4eCE1+A+P/+o4eCE3OA+P/+oAEAAAAAAAAPoYeCE4cA+P/+daKDB/KBHFO7a5G7j7OBB7eK94EB8YIDX/CBDA==",
		ce = () => "wakeLock" in navigator && window.navigator.userAgent.indexOf("Samsung") === -1;
	class Oe {
		constructor() {
			if (ce()) {
				NP_DEBUG("keepScreenOn native implementation"), this._wakeLock = null;
				const e = () => {
					this._wakeLock !== null && document.visibilityState === "visible" && this.enable()
				};
				document.addEventListener("visibilitychange", e), document.addEventListener("fullscreenchange", e)
			} else NP_DEBUG("keepScreenOn simulation implementation"), this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this._addSourceToVideo(this.noSleepVideo, "webm", ke), this._addSourceToVideo(this.noSleepVideo, "mp4", Fe), Object.assign(this.noSleepVideo.style, {
				position: "absolute",
				left: "-100%",
				top: "-100%"
			}), this.noSleepVideo.addEventListener("timeupdate", () => {
				this.noSleepVideo.currentTime > 4 && (this.noSleepVideo.currentTime = 1)
			})
		}
		_addSourceToVideo(e, t, i) {
			var s = document.createElement("source");
			s.src = i, s.type = `video/${t}`, e.appendChild(s)
		}
		enable() {
			if (ce()) return navigator.wakeLock.request("screen").then(e => {
				this._wakeLock = e, NP_DEBUG("Wake Lock active."), this._wakeLock.addEventListener("release", () => {
					NP_DEBUG("Wake Lock released.")
				})
			}).catch(e => {
				NP_DEBUG(`${e.name}, ${e.message}`)
			});
			document.querySelector("body").append(this.noSleepVideo), this.noSleepVideo.play()
		}
		disable() {
			if (ce()) this._wakeLock && this._wakeLock.release(), this._wakeLock = null;
			else {
				this.noSleepVideo.pause();
				try {
					this.noSleepVideo.parentNode && this.noSleepVideo.parentNode.removeChild(this.noSleepVideo)
				} catch (e) {
					NP_DEBUG("Did not unmount video - likely nosleep was never enabled")
				}
			}
		}
	}

	function y() {
		this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
	}
	y.EventEmitter = y, y.prototype._events = void 0, y.prototype._maxListeners = void 0, y.defaultMaxListeners = 10, y.prototype.setMaxListeners = function(a) {
		if (!Ue(a) || a < 0 || isNaN(a)) throw TypeError("n must be a positive number");
		return this._maxListeners = a, this
	}, y.prototype.emit = function(a) {
		var e, t, i, s, r, n;
		if (this._events || (this._events = {}), a === "error" && (!this._events.error || te(this._events.error) && !this._events.error.length)) {
			if (e = arguments[1], e instanceof Error) throw e;
			var A = new Error('Uncaught, unspecified "error" event. (' + e + ")");
			throw A.context = e, A
		}
		if (t = this._events[a], pe(t)) return !1;
		if (W(t)) switch (arguments.length) {
			case 1:
				t.call(this);
				break;
			case 2:
				t.call(this, arguments[1]);
				break;
			case 3:
				t.call(this, arguments[1], arguments[2]);
				break;
			default:
				s = Array.prototype.slice.call(arguments, 1), t.apply(this, s)
		} else if (te(t))
			for (s = Array.prototype.slice.call(arguments, 1), n = t.slice(), i = n.length, r = 0; r < i; r++) n[r].apply(this, s);
		return !0
	}, y.prototype.addListener = function(a, e) {
		var t;
		if (!W(e)) throw TypeError("listener must be a function");
		return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", a, W(e.listener) ? e.listener : e), this._events[a] ? te(this._events[a]) ? this._events[a].push(e) : this._events[a] = [this._events[a], e] : this._events[a] = e, te(this._events[a]) && !this._events[a].warned && (pe(this._maxListeners) ? t = y.defaultMaxListeners : t = this._maxListeners, t && t > 0 && this._events[a].length > t && (this._events[a].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a].length), typeof console.trace == "function" && console.trace())), this
	}, y.prototype.on = y.prototype.addListener, y.prototype.once = function(a, e) {
		if (!W(e)) throw TypeError("listener must be a function");
		var t = !1;

		function i() {
			this.removeListener(a, i), t || (t = !0, e.apply(this, arguments))
		}
		return i.listener = e, this.on(a, i), this
	}, y.prototype.removeListener = function(a, e) {
		var t, i, s, r;
		if (!W(e)) throw TypeError("listener must be a function");
		if (!this._events || !this._events[a]) return this;
		if (t = this._events[a], s = t.length, i = -1, t === e || W(t.listener) && t.listener === e) delete this._events[a], this._events.removeListener && this.emit("removeListener", a, e);
		else if (te(t)) {
			for (r = s; r-- > 0;)
				if (t[r] === e || t[r].listener && t[r].listener === e) {
					i = r;
					break
				} if (i < 0) return this;
			t.length === 1 ? (t.length = 0, delete this._events[a]) : t.splice(i, 1), this._events.removeListener && this.emit("removeListener", a, e)
		}
		return this
	}, y.prototype.removeAllListeners = function(a) {
		var e, t;
		if (!this._events) return this;
		if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[a] && delete this._events[a], this;
		if (arguments.length === 0) {
			for (e in this._events) e !== "removeListener" && this.removeAllListeners(e);
			return this.removeAllListeners("removeListener"), this._events = {}, this
		}
		if (t = this._events[a], W(t)) this.removeListener(a, t);
		else if (t)
			for (; t.length;) this.removeListener(a, t[t.length - 1]);
		return delete this._events[a], this
	}, y.prototype.listeners = function(a) {
		var e;
		return !this._events || !this._events[a] ? e = [] : W(this._events[a]) ? e = [this._events[a]] : e = this._events[a].slice(), e
	}, y.prototype.listenerCount = function(a) {
		if (this._events) {
			var e = this._events[a];
			if (W(e)) return 1;
			if (e) return e.length
		}
		return 0
	}, y.listenerCount = function(a, e) {
		return a.listenerCount(e)
	};

	function W(a) {
		return typeof a == "function"
	}

	function Ue(a) {
		return typeof a == "number"
	}

	function te(a) {
		return typeof a == "object" && a !== null
	}

	function pe(a) {
		return a === void 0
	}
	class o {
		static e(e, t) {
			(!e || o.FORCE_GLOBAL_TAG) && (e = o.GLOBAL_TAG);
			let i = `[${e}] > ${t}`;
			o.ENABLE_CALLBACK && o.emitter.emit("log", "error", i), !!o.ENABLE_ERROR && (console.error ? console.error(i) : console.warn ? console.warn(i) : console.log(i))
		}
		static i(e, t) {
			(!e || o.FORCE_GLOBAL_TAG) && (e = o.GLOBAL_TAG);
			let i = `[${e}] > ${t}`;
			o.ENABLE_CALLBACK && o.emitter.emit("log", "info", i), !!o.ENABLE_INFO && (console.info ? console.info(i) : console.log(i))
		}
		static w(e, t) {
			(!e || o.FORCE_GLOBAL_TAG) && (e = o.GLOBAL_TAG);
			let i = `[${e}] > ${t}`;
			o.ENABLE_CALLBACK && o.emitter.emit("log", "warn", i), !!o.ENABLE_WARN && (console.warn ? console.warn(i) : console.log(i))
		}
		static d(e, t) {
			(!e || o.FORCE_GLOBAL_TAG) && (e = o.GLOBAL_TAG);
			let i = `[${e}] > ${t}`;
			o.ENABLE_CALLBACK && o.emitter.emit("log", "debug", i), !!o.ENABLE_DEBUG && (console.debug ? console.debug(i) : console.log(i))
		}
		static v(e, t) {
			(!e || o.FORCE_GLOBAL_TAG) && (e = o.GLOBAL_TAG);
			let i = `[${e}] > ${t}`;
			o.ENABLE_CALLBACK && o.emitter.emit("log", "verbose", i), !!o.ENABLE_VERBOSE && console.log(i)
		}
	}
	o.GLOBAL_TAG = "flv.js", o.FORCE_GLOBAL_TAG = !1, o.ENABLE_ERROR = !0, o.ENABLE_INFO = !0, o.ENABLE_WARN = !0, o.ENABLE_DEBUG = !0, o.ENABLE_VERBOSE = !0, o.ENABLE_CALLBACK = !1, o.emitter = new y;
	class xe {
		constructor() {
			this._firstCheckpoint = 0, this._lastCheckpoint = 0, this._intervalBytes = 0, this._totalBytes = 0, this._lastSecondBytes = 0, self.performance && self.performance.now ? this._now = self.performance.now.bind(self.performance) : this._now = Date.now
		}
		reset() {
			this._firstCheckpoint = this._lastCheckpoint = 0, this._totalBytes = this._intervalBytes = 0, this._lastSecondBytes = 0
		}
		addBytes(e) {
			this._firstCheckpoint === 0 ? (this._firstCheckpoint = this._now(), this._lastCheckpoint = this._firstCheckpoint, this._intervalBytes += e, this._totalBytes += e) : this._now() - this._lastCheckpoint < 1e3 ? (this._intervalBytes += e, this._totalBytes += e) : (this._lastSecondBytes = this._intervalBytes, this._intervalBytes = e, this._totalBytes += e, this._lastCheckpoint = this._now())
		}
		get currentKBps() {
			this.addBytes(0);
			let e = (this._now() - this._lastCheckpoint) / 1e3;
			return e == 0 && (e = 1), this._intervalBytes / e / 1024
		}
		get lastSecondKBps() {
			return this.addBytes(0), this._lastSecondBytes !== 0 ? this._lastSecondBytes / 1024 : this._now() - this._lastCheckpoint >= 500 ? this.currentKBps : 0
		}
		get averageKBps() {
			let e = (this._now() - this._firstCheckpoint) / 1e3;
			return this._totalBytes / e / 1024
		}
	}
	class P {
		constructor(e) {
			this._message = e
		}
		get name() {
			return "RuntimeException"
		}
		get message() {
			return this._message
		}
		toString() {
			return this.name + ": " + this.message
		}
	}
	class G extends P {
		constructor(e) {
			super(e)
		}
		get name() {
			return "IllegalStateException"
		}
	}
	class j extends P {
		constructor(e) {
			super(e)
		}
		get name() {
			return "InvalidArgumentException"
		}
	}
	class Ee extends P {
		constructor(e) {
			super(e)
		}
		get name() {
			return "NotImplementedException"
		}
	}
	const w = {
			kIdle: 0,
			kConnecting: 1,
			kBuffering: 2,
			kError: 3,
			kComplete: 4
		},
		T = {
			OK: "OK",
			EXCEPTION: "Exception",
			HTTP_STATUS_CODE_INVALID: "HttpStatusCodeInvalid",
			CONNECTING_TIMEOUT: "ConnectingTimeout",
			EARLY_EOF: "EarlyEof",
			UNRECOVERABLE_EARLY_EOF: "UnrecoverableEarlyEof"
		};
	class Ae {
		constructor(e) {
			this._type = e || "undefined", this._status = w.kIdle, this._needStash = !1, this._onContentLengthKnown = null, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null
		}
		destroy() {
			this._status = w.kIdle, this._onContentLengthKnown = null, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null
		}
		isWorking() {
			return this._status === w.kConnecting || this._status === w.kBuffering
		}
		get type() {
			return this._type
		}
		get status() {
			return this._status
		}
		get needStashBuffer() {
			return this._needStash
		}
		get onContentLengthKnown() {
			return this._onContentLengthKnown
		}
		set onContentLengthKnown(e) {
			this._onContentLengthKnown = e
		}
		get onURLRedirect() {
			return this._onURLRedirect
		}
		set onURLRedirect(e) {
			this._onURLRedirect = e
		}
		get onDataArrival() {
			return this._onDataArrival
		}
		set onDataArrival(e) {
			this._onDataArrival = e
		}
		get onError() {
			return this._onError
		}
		set onError(e) {
			this._onError = e
		}
		get onComplete() {
			return this._onComplete
		}
		set onComplete(e) {
			this._onComplete = e
		}
		open(e, t) {
			throw new Ee("Unimplemented abstract function!")
		}
		abort() {
			throw new Ee("Unimplemented abstract function!")
		}
	}
	let R = {};

	function Pe() {
		let a = self.navigator.userAgent.toLowerCase(),
			e = /(edge)\/([\w.]+)/.exec(a) || /(opr)[\/]([\w.]+)/.exec(a) || /(chrome)[ \/]([\w.]+)/.exec(a) || /(iemobile)[\/]([\w.]+)/.exec(a) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(a) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(a) || /(webkit)[ \/]([\w.]+)/.exec(a) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(a) || /(msie) ([\w.]+)/.exec(a) || a.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(a) || a.indexOf("compatible") < 0 && /(firefox)[ \/]([\w.]+)/.exec(a) || [],
			t = /(ipad)/.exec(a) || /(ipod)/.exec(a) || /(windows phone)/.exec(a) || /(iphone)/.exec(a) || /(kindle)/.exec(a) || /(android)/.exec(a) || /(windows)/.exec(a) || /(mac)/.exec(a) || /(linux)/.exec(a) || /(cros)/.exec(a) || [],
			i = {
				browser: e[5] || e[3] || e[1] || "",
				version: e[2] || e[4] || "0",
				majorVersion: e[4] || e[2] || "0",
				platform: t[0] || ""
			},
			s = {};
		if (i.browser) {
			s[i.browser] = !0;
			let r = i.majorVersion.split(".");
			s.version = {
				major: parseInt(i.majorVersion, 10),
				string: i.version
			}, r.length > 1 && (s.version.minor = parseInt(r[1], 10)), r.length > 2 && (s.version.build = parseInt(r[2], 10))
		}
		if (i.platform && (s[i.platform] = !0), (s.chrome || s.opr || s.safari) && (s.webkit = !0), s.rv || s.iemobile) {
			s.rv && delete s.rv;
			let r = "msie";
			i.browser = r, s[r] = !0
		}
		if (s.edge) {
			delete s.edge;
			let r = "msedge";
			i.browser = r, s[r] = !0
		}
		if (s.opr) {
			let r = "opera";
			i.browser = r, s[r] = !0
		}
		if (s.safari && s.android) {
			let r = "android";
			i.browser = r, s[r] = !0
		}
		s.name = i.browser, s.platform = i.platform;
		for (let r in R) R.hasOwnProperty(r) && delete R[r];
		Object.assign(R, s)
	}
	Pe();
	class ae extends Ae {
		static isSupported() {
			try {
				let e = R.msedge && R.version.minor >= 15048,
					t = R.msedge ? e : !0;
				return self.fetch && self.ReadableStream && t
			} catch (e) {
				return !1
			}
		}
		constructor(e, t) {
			super("fetch-stream-loader");
			this.TAG = "FetchStreamLoader", this._seekHandler = e, this._config = t, this._needStash = !0, this._requestAbort = !1, this._contentLength = null, this._receivedLength = 0, this._reader = null
		}
		destroy() {
			this.isWorking() && this.abort(), super.destroy()
		}
		open(e, t) {
			let i = null;
			if (self.AbortController) {
				let h = new self.AbortController;
				i = h.signal, this._fetchAbortController = h
			}
			this._dataSource = e, this._range = t;
			let s = e.url;
			this._config.reuseRedirectedURL && e.redirectedURL != null && (s = e.redirectedURL);
			let r = this._seekHandler.getConfig(s, t),
				n = new self.Headers;
			if (typeof r.headers == "object") {
				let h = r.headers;
				for (let d in h) h.hasOwnProperty(d) && n.append(d, h[d])
			}
			let A = {
				method: "GET",
				headers: n,
				mode: "cors",
				cache: "default",
				referrerPolicy: "no-referrer-when-downgrade",
				signal: i
			};
			if (typeof this._config.headers == "object")
				for (let h in this._config.headers) n.append(h, this._config.headers[h]);
			e.cors === !1 && (A.mode = "same-origin"), e.withCredentials && (A.credentials = "include"), e.referrerPolicy && (A.referrerPolicy = e.referrerPolicy), this._status = w.kConnecting, self.fetch(r.url, A).then(h => {
				if (this._requestAbort) {
					this._requestAbort = !1, this._status = w.kIdle;
					return
				}
				if (h.ok && h.status >= 200 && h.status <= 299) {
					if (h.url !== r.url && this._onURLRedirect) {
						let _ = this._seekHandler.removeURLParameters(h.url);
						this._onURLRedirect(_)
					}
					let d = h.headers.get("Content-Length");
					return d != null && (this._contentLength = parseInt(d), this._contentLength !== 0 && this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength)), this._pump.call(this, h.body.getReader())
				} else if (this._status = w.kError, this._onError) this._onError(T.HTTP_STATUS_CODE_INVALID, {
					code: h.status,
					msg: h.statusText
				});
				else throw new P("FetchStreamLoader: Http code invalid, " + h.status + " " + h.statusText)
			}).catch(h => {
				if (this._requestAbort) {
					this._requestAbort = !1;
					return
				}
				if (this._status = w.kError, this._onError) this._onError(T.EXCEPTION, {
					code: -1,
					msg: h.message
				});
				else throw h
			})
		}
		abort() {
			this._requestAbort = !0, this._fetchAbortController && this._fetchAbortController.abort()
		}
		_pump(e) {
			return e.read().then(t => {
				if (t.done)
					if (this._contentLength !== null && this._receivedLength < this._contentLength) {
						this._status = w.kError;
						let i = T.EARLY_EOF,
							s = {
								code: -1,
								msg: "Fetch stream meet Early-EOF"
							};
						if (this._onError) this._onError(i, s);
						else throw new P(s.msg)
					} else this._status = w.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);
				else {
					if (this._requestAbort === !0) return this._requestAbort = !1, this._status = w.kComplete, e.cancel();
					this._status = w.kBuffering;
					let i = t.value.buffer,
						s = this._range.from + this._receivedLength;
					this._receivedLength += i.byteLength, this._onDataArrival && this._onDataArrival(i, s, this._receivedLength), this._pump(e)
				}
			}).catch(t => {
				if (this._requestAbort) {
					this._requestAbort = !1;
					return
				}
				if (t.code === 11 && R.msedge) return;
				this._status = w.kError;
				let i = 0,
					s = null;
				if ((t.code === 19 || t.message === "network error") && (this._contentLength === null || this._contentLength !== null && this._receivedLength < this._contentLength) ? (i = T.EARLY_EOF, s = {
						code: t.code,
						msg: "Fetch stream meet Early-EOF"
					}) : (i = T.EXCEPTION, s = {
						code: t.code,
						msg: t.message
					}), this._onError) this._onError(i, s);
				else throw new P(s.msg)
			})
		}
	}
	class oe extends Ae {
		static isSupported() {
			try {
				let e = new XMLHttpRequest;
				return e.open("GET", "https://example.com", !0), e.responseType = "moz-chunked-arraybuffer", e.responseType === "moz-chunked-arraybuffer"
			} catch (e) {
				return o.w("MozChunkedLoader", e.message), !1
			}
		}
		constructor(e, t) {
			super("xhr-moz-chunked-loader");
			this.TAG = "MozChunkedLoader", this._seekHandler = e, this._config = t, this._needStash = !0, this._xhr = null, this._requestAbort = !1, this._contentLength = null, this._receivedLength = 0
		}
		destroy() {
			this.isWorking() && this.abort(), this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onloadend = null, this._xhr.onerror = null, this._xhr = null), super.destroy()
		}
		open(e, t) {
			this._dataSource = e, this._range = t;
			let i = e.url;
			this._config.reuseRedirectedURL && e.redirectedURL != null && (i = e.redirectedURL);
			let s = this._seekHandler.getConfig(i, t);
			this._requestURL = s.url;
			let r = this._xhr = new XMLHttpRequest;
			if (r.open("GET", s.url, !0), r.responseType = "moz-chunked-arraybuffer", r.onreadystatechange = this._onReadyStateChange.bind(this), r.onprogress = this._onProgress.bind(this), r.onloadend = this._onLoadEnd.bind(this), r.onerror = this._onXhrError.bind(this), e.withCredentials && (r.withCredentials = !0), typeof s.headers == "object") {
				let n = s.headers;
				for (let A in n) n.hasOwnProperty(A) && r.setRequestHeader(A, n[A])
			}
			if (typeof this._config.headers == "object") {
				let n = this._config.headers;
				for (let A in n) n.hasOwnProperty(A) && r.setRequestHeader(A, n[A])
			}
			this._status = w.kConnecting, r.send()
		}
		abort() {
			this._requestAbort = !0, this._xhr && this._xhr.abort(), this._status = w.kComplete
		}
		_onReadyStateChange(e) {
			let t = e.target;
			if (t.readyState === 2) {
				if (t.responseURL != null && t.responseURL !== this._requestURL && this._onURLRedirect) {
					let i = this._seekHandler.removeURLParameters(t.responseURL);
					this._onURLRedirect(i)
				}
				if (t.status !== 0 && (t.status < 200 || t.status > 299))
					if (this._status = w.kError, this._onError) this._onError(T.HTTP_STATUS_CODE_INVALID, {
						code: t.status,
						msg: t.statusText
					});
					else throw new P("MozChunkedLoader: Http code invalid, " + t.status + " " + t.statusText);
				else this._status = w.kBuffering
			}
		}
		_onProgress(e) {
			if (this._status === w.kError) return;
			this._contentLength === null && e.total !== null && e.total !== 0 && (this._contentLength = e.total, this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength));
			let t = e.target.response,
				i = this._range.from + this._receivedLength;
			this._receivedLength += t.byteLength, this._onDataArrival && this._onDataArrival(t, i, this._receivedLength)
		}
		_onLoadEnd(e) {
			if (this._requestAbort === !0) {
				this._requestAbort = !1;
				return
			} else if (this._status === w.kError) return;
			this._status = w.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1)
		}
		_onXhrError(e) {
			this._status = w.kError;
			let t = 0,
				i = null;
			if (this._contentLength && e.loaded < this._contentLength ? (t = T.EARLY_EOF, i = {
					code: -1,
					msg: "Moz-Chunked stream meet Early-Eof"
				}) : (t = T.EXCEPTION, i = {
					code: -1,
					msg: e.constructor.name + " " + e.type
				}), this._onError) this._onError(t, i);
			else throw new P(i.msg)
		}
	}
	class ie extends Ae {
		static isSupported() {
			try {
				let e = new XMLHttpRequest;
				return e.open("GET", "https://example.com", !0), e.responseType = "arraybuffer", e.responseType === "arraybuffer"
			} catch (e) {
				return o.w("RangeLoader", e.message), !1
			}
		}
		constructor(e, t) {
			super("xhr-range-loader");
			this.TAG = "RangeLoader", this._seekHandler = e, this._config = t, this._needStash = !1, this._chunkSizeKBList = [128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192], this._currentChunkSizeKB = 384, this._currentSpeedNormalized = 0, this._zeroSpeedChunkCount = 0, this._xhr = null, this._speedSampler = new xe, this._requestAbort = !1, this._waitForTotalLength = !1, this._totalLengthReceived = !1, this._currentRequestURL = null, this._currentRedirectedURL = null, this._currentRequestRange = null, this._totalLength = null, this._contentLength = null, this._receivedLength = 0, this._lastTimeLoaded = 0
		}
		destroy() {
			this.isWorking() && this.abort(), this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onload = null, this._xhr.onerror = null, this._xhr = null), super.destroy()
		}
		get currentSpeed() {
			return this._speedSampler.lastSecondKBps
		}
		open(e, t) {
			this._dataSource = e, this._range = t, this._status = w.kConnecting;
			let i = !1;
			this._dataSource.filesize != null && this._dataSource.filesize !== 0 && (i = !0, this._totalLength = this._dataSource.filesize), !this._totalLengthReceived && !i ? (this._waitForTotalLength = !0, this._internalOpen(this._dataSource, {
				from: 0,
				to: -1
			})) : this._openSubRange()
		}
		_openSubRange() {
			let e = this._currentChunkSizeKB * 1024,
				t = this._range.from + this._receivedLength,
				i = t + e;
			this._contentLength != null && i - this._range.from >= this._contentLength && (i = this._range.from + this._contentLength - 1), this._currentRequestRange = {
				from: t,
				to: i
			}, this._internalOpen(this._dataSource, this._currentRequestRange)
		}
		_internalOpen(e, t) {
			this._lastTimeLoaded = 0;
			let i = e.url;
			this._config.reuseRedirectedURL && (this._currentRedirectedURL != null ? i = this._currentRedirectedURL : e.redirectedURL != null && (i = e.redirectedURL));
			let s = this._seekHandler.getConfig(i, t);
			this._currentRequestURL = s.url;
			let r = this._xhr = new XMLHttpRequest;
			if (r.open("GET", s.url, !0), r.responseType = "arraybuffer", r.onreadystatechange = this._onReadyStateChange.bind(this), r.onprogress = this._onProgress.bind(this), r.onload = this._onLoad.bind(this), r.onerror = this._onXhrError.bind(this), e.withCredentials && (r.withCredentials = !0), typeof s.headers == "object") {
				let n = s.headers;
				for (let A in n) n.hasOwnProperty(A) && r.setRequestHeader(A, n[A])
			}
			if (typeof this._config.headers == "object") {
				let n = this._config.headers;
				for (let A in n) n.hasOwnProperty(A) && r.setRequestHeader(A, n[A])
			}
			r.send()
		}
		abort() {
			this._requestAbort = !0, this._internalAbort(), this._status = w.kComplete
		}
		_internalAbort() {
			this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onload = null, this._xhr.onerror = null, this._xhr.abort(), this._xhr = null)
		}
		_onReadyStateChange(e) {
			let t = e.target;
			if (t.readyState === 2) {
				if (t.responseURL != null) {
					let i = this._seekHandler.removeURLParameters(t.responseURL);
					t.responseURL !== this._currentRequestURL && i !== this._currentRedirectedURL && (this._currentRedirectedURL = i, this._onURLRedirect && this._onURLRedirect(i))
				}
				if (t.status >= 200 && t.status <= 299) {
					if (this._waitForTotalLength) return;
					this._status = w.kBuffering
				} else if (this._status = w.kError, this._onError) this._onError(T.HTTP_STATUS_CODE_INVALID, {
					code: t.status,
					msg: t.statusText
				});
				else throw new P("RangeLoader: Http code invalid, " + t.status + " " + t.statusText)
			}
		}
		_onProgress(e) {
			if (this._status === w.kError) return;
			if (this._contentLength === null) {
				let i = !1;
				if (this._waitForTotalLength) {
					this._waitForTotalLength = !1, this._totalLengthReceived = !0, i = !0;
					let s = e.total;
					this._internalAbort(), s != null & s !== 0 && (this._totalLength = s)
				}
				if (this._range.to === -1 ? this._contentLength = this._totalLength - this._range.from : this._contentLength = this._range.to - this._range.from + 1, i) {
					this._openSubRange();
					return
				}
				this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength)
			}
			let t = e.loaded - this._lastTimeLoaded;
			this._lastTimeLoaded = e.loaded, this._speedSampler.addBytes(t)
		}
		_normalizeSpeed(e) {
			let t = this._chunkSizeKBList,
				i = t.length - 1,
				s = 0,
				r = 0,
				n = i;
			if (e < t[0]) return t[0];
			for (; r <= n;) {
				if (s = r + Math.floor((n - r) / 2), s === i || e >= t[s] && e < t[s + 1]) return t[s];
				t[s] < e ? r = s + 1 : n = s - 1
			}
		}
		_onLoad(e) {
			if (this._status === w.kError) return;
			if (this._waitForTotalLength) {
				this._waitForTotalLength = !1;
				return
			}
			this._lastTimeLoaded = 0;
			let t = this._speedSampler.lastSecondKBps;
			if (t === 0 && (this._zeroSpeedChunkCount++, this._zeroSpeedChunkCount >= 3 && (t = this._speedSampler.currentKBps)), t !== 0) {
				let n = this._normalizeSpeed(t);
				this._currentSpeedNormalized !== n && (this._currentSpeedNormalized = n, this._currentChunkSizeKB = n)
			}
			let i = e.target.response,
				s = this._range.from + this._receivedLength;
			this._receivedLength += i.byteLength;
			let r = !1;
			this._contentLength != null && this._receivedLength < this._contentLength ? this._openSubRange() : r = !0, this._onDataArrival && this._onDataArrival(i, s, this._receivedLength), r && (this._status = w.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1))
		}
		_onXhrError(e) {
			this._status = w.kError;
			let t = 0,
				i = null;
			if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength ? (t = T.EARLY_EOF, i = {
					code: -1,
					msg: "RangeLoader meet Early-Eof"
				}) : (t = T.EXCEPTION, i = {
					code: -1,
					msg: e.constructor.name + " " + e.type
				}), this._onError) this._onError(t, i);
			else throw new P(i.msg)
		}
	}
	class Se extends Ae {
		static isSupported() {
			try {
				return typeof self.WebSocket != "undefined"
			} catch (e) {
				return !1
			}
		}
		constructor() {
			super("websocket-loader");
			this.TAG = "WebSocketLoader", this._needStash = !0, this._ws = null, this._requestAbort = !1, this._receivedLength = 0
		}
		destroy() {
			this._ws && this.abort(), super.destroy()
		}
		open(e) {
			try {
				let t = this._ws = new self.WebSocket(e.url);
				t.binaryType = "arraybuffer", t.onopen = this._onWebSocketOpen.bind(this), t.onclose = this._onWebSocketClose.bind(this), t.onmessage = this._onWebSocketMessage.bind(this), t.onerror = this._onWebSocketError.bind(this), this._status = w.kConnecting
			} catch (t) {
				this._status = w.kError;
				let i = {
					code: t.code,
					msg: t.message
				};
				if (this._onError) this._onError(T.EXCEPTION, i);
				else throw new P(i.msg)
			}
		}
		abort() {
			let e = this._ws;
			e && (e.readyState === 0 || e.readyState === 1) && (this._requestAbort = !0, e.close()), this._ws = null, this._status = w.kComplete
		}
		_onWebSocketOpen(e) {
			this._status = w.kBuffering
		}
		_onWebSocketClose(e) {
			if (this._requestAbort === !0) {
				this._requestAbort = !1;
				return
			}
			this._status = w.kComplete, this._onComplete && this._onComplete(0, this._receivedLength - 1)
		}
		_onWebSocketMessage(e) {
			if (e.data instanceof ArrayBuffer) this._dispatchArrayBuffer(e.data);
			else if (e.data instanceof Blob) {
				let t = new FileReader;
				t.onload = () => {
					this._dispatchArrayBuffer(t.result)
				}, t.readAsArrayBuffer(e.data)
			} else {
				this._status = w.kError;
				let t = {
					code: -1,
					msg: "Unsupported WebSocket message type: " + e.data.constructor.name
				};
				if (this._onError) this._onError(T.EXCEPTION, t);
				else throw new P(t.msg)
			}
		}
		_dispatchArrayBuffer(e) {
			let t = e,
				i = this._receivedLength;
			this._receivedLength += t.byteLength, this._onDataArrival && this._onDataArrival(t, i, this._receivedLength)
		}
		_onWebSocketError(e) {
			this._status = w.kError;
			let t = {
				code: e.code,
				msg: e.message
			};
			if (this._onError) this._onError(T.EXCEPTION, t);
			else throw new P(t.msg)
		}
	}
	class Be {
		constructor(e) {
			this._zeroStart = e || !1
		}
		getConfig(e, t) {
			let i = {};
			if (t.from !== 0 || t.to !== -1) {
				let s;
				t.to !== -1 ? s = `bytes=${t.from.toString()}-${t.to.toString()}` : s = `bytes=${t.from.toString()}-`, i.Range = s
			} else this._zeroStart && (i.Range = "bytes=0-");
			return {
				url: e,
				headers: i
			}
		}
		removeURLParameters(e) {
			return e
		}
	}
	class Ce {
		constructor(e, t) {
			this._startName = e, this._endName = t
		}
		getConfig(e, t) {
			let i = e;
			if (t.from !== 0 || t.to !== -1) {
				let s = !0;
				i.indexOf("?") === -1 && (i += "?", s = !1), s && (i += "&"), i += `${this._startName}=${t.from.toString()}`, t.to !== -1 && (i += `&${this._endName}=${t.to.toString()}`)
			}
			return {
				url: i,
				headers: {}
			}
		}
		removeURLParameters(e) {
			let t = e.split("?")[0],
				i, s = e.indexOf("?");
			s !== -1 && (i = e.substring(s + 1));
			let r = "";
			if (i != null && i.length > 0) {
				let n = i.split("&");
				for (let A = 0; A < n.length; A++) {
					let h = n[A].split("="),
						d = A > 0;
					h[0] !== this._startName && h[0] !== this._endName && (d && (r += "&"), r += n[A])
				}
			}
			return r.length === 0 ? t : t + "?" + r
		}
	}
	class fe {
		constructor(e, t, i) {
			this.TAG = "IOController", this._config = t, this._extraData = i, this._stashInitialSize = 1024 * 384, t.stashInitialSize != null && t.stashInitialSize > 0 && (this._stashInitialSize = t.stashInitialSize), this._stashUsed = 0, this._stashSize = this._stashInitialSize, this._bufferSize = 1024 * 1024 * 3, this._stashBuffer = new ArrayBuffer(this._bufferSize), this._stashByteStart = 0, this._enableStash = !0, t.enableStashBuffer === !1 && (this._enableStash = !1), this._loader = null, this._loaderClass = null, this._seekHandler = null, this._dataSource = e, this._isWebSocketURL = /wss?:\/\/(.+?)/.test(e.url), this._refTotalLength = e.filesize ? e.filesize : null, this._totalLength = this._refTotalLength, this._fullRequestFlag = !1, this._currentRange = null, this._redirectedURL = null, this._speedNormalized = 0, this._speedSampler = new xe, this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096], this._isEarlyEofReconnecting = !1, this._paused = !1, this._resumeFrom = 0, this._onDataArrival = null, this._onSeeked = null, this._onError = null, this._onComplete = null, this._onRedirect = null, this._onRecoveredEarlyEof = null, this._selectSeekHandler(), this._selectLoader(), this._createLoader()
		}
		destroy() {
			this._loader.isWorking() && this._loader.abort(), this._loader.destroy(), this._loader = null, this._loaderClass = null, this._dataSource = null, this._stashBuffer = null, this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0, this._currentRange = null, this._speedSampler = null, this._isEarlyEofReconnecting = !1, this._onDataArrival = null, this._onSeeked = null, this._onError = null, this._onComplete = null, this._onRedirect = null, this._onRecoveredEarlyEof = null, this._extraData = null
		}
		isWorking() {
			return this._loader && this._loader.isWorking() && !this._paused
		}
		isPaused() {
			return this._paused
		}
		get status() {
			return this._loader.status
		}
		get extraData() {
			return this._extraData
		}
		set extraData(e) {
			this._extraData = e
		}
		get onDataArrival() {
			return this._onDataArrival
		}
		set onDataArrival(e) {
			this._onDataArrival = e
		}
		get onSeeked() {
			return this._onSeeked
		}
		set onSeeked(e) {
			this._onSeeked = e
		}
		get onError() {
			return this._onError
		}
		set onError(e) {
			this._onError = e
		}
		get onComplete() {
			return this._onComplete
		}
		set onComplete(e) {
			this._onComplete = e
		}
		get onRedirect() {
			return this._onRedirect
		}
		set onRedirect(e) {
			this._onRedirect = e
		}
		get onRecoveredEarlyEof() {
			return this._onRecoveredEarlyEof
		}
		set onRecoveredEarlyEof(e) {
			this._onRecoveredEarlyEof = e
		}
		get currentURL() {
			return this._dataSource.url
		}
		get hasRedirect() {
			return this._redirectedURL != null || this._dataSource.redirectedURL != null
		}
		get currentRedirectedURL() {
			return this._redirectedURL || this._dataSource.redirectedURL
		}
		get currentSpeed() {
			return this._loaderClass === ie ? this._loader.currentSpeed : this._speedSampler.lastSecondKBps
		}
		get loaderType() {
			return this._loader.type
		}
		_selectSeekHandler() {
			let e = this._config;
			if (e.seekType === "range") this._seekHandler = new Be(this._config.rangeLoadZeroStart);
			else if (e.seekType === "param") {
				let t = e.seekParamStart || "bstart",
					i = e.seekParamEnd || "bend";
				this._seekHandler = new Ce(t, i)
			} else if (e.seekType === "custom") {
				if (typeof e.customSeekHandler != "function") throw new j("Custom seekType specified in config but invalid customSeekHandler!");
				this._seekHandler = new e.customSeekHandler
			} else throw new j(`Invalid seekType in config: ${e.seekType}`)
		}
		_selectLoader() {
			if (this._config.customLoader != null) this._loaderClass = this._config.customLoader;
			else if (this._isWebSocketURL) this._loaderClass = Se;
			else if (ae.isSupported()) this._loaderClass = ae;
			else if (oe.isSupported()) this._loaderClass = oe;
			else if (ie.isSupported()) this._loaderClass = ie;
			else throw new P("Your browser doesn't support xhr with arraybuffer responseType!")
		}
		_createLoader() {
			this._loader = new this._loaderClass(this._seekHandler, this._config), this._loader.needStashBuffer === !1 && (this._enableStash = !1), this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this), this._loader.onURLRedirect = this._onURLRedirect.bind(this), this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this), this._loader.onComplete = this._onLoaderComplete.bind(this), this._loader.onError = this._onLoaderError.bind(this)
		}
		open(e) {
			this._currentRange = {
				from: 0,
				to: -1
			}, e && (this._currentRange.from = e), this._speedSampler.reset(), e || (this._fullRequestFlag = !0), this._loader.open(this._dataSource, Object.assign({}, this._currentRange))
		}
		abort() {
			this._loader.abort(), this._paused && (this._paused = !1, this._resumeFrom = 0)
		}
		pause() {
			this.isWorking() && (this._loader.abort(), this._stashUsed !== 0 ? (this._resumeFrom = this._stashByteStart, this._currentRange.to = this._stashByteStart - 1) : this._resumeFrom = this._currentRange.to + 1, this._stashUsed = 0, this._stashByteStart = 0, this._paused = !0)
		}
		resume() {
			if (this._paused) {
				this._paused = !1;
				let e = this._resumeFrom;
				this._resumeFrom = 0, this._internalSeek(e, !0)
			}
		}
		seek(e) {
			this._paused = !1, this._stashUsed = 0, this._stashByteStart = 0, this._internalSeek(e, !0)
		}
		_internalSeek(e, t) {
			this._loader.isWorking() && this._loader.abort(), this._flushStashBuffer(t), this._loader.destroy(), this._loader = null;
			let i = {
				from: e,
				to: -1
			};
			this._currentRange = {
				from: i.from,
				to: -1
			}, this._speedSampler.reset(), this._stashSize = this._stashInitialSize, this._createLoader(), this._loader.open(this._dataSource, i), this._onSeeked && this._onSeeked()
		}
		updateUrl(e) {
			if (!e || typeof e != "string" || e.length === 0) throw new j("Url must be a non-empty string!");
			this._dataSource.url = e
		}
		_expandBuffer(e) {
			let t = this._stashSize;
			for (; t + 1024 * 1024 * 1 < e;) t *= 2;
			if (t += 1024 * 1024 * 1, t === this._bufferSize) return;
			let i = new ArrayBuffer(t);
			if (this._stashUsed > 0) {
				let s = new Uint8Array(this._stashBuffer, 0, this._stashUsed);
				new Uint8Array(i, 0, t).set(s, 0)
			}
			this._stashBuffer = i, this._bufferSize = t
		}
		_normalizeSpeed(e) {
			let t = this._speedNormalizeList,
				i = t.length - 1,
				s = 0,
				r = 0,
				n = i;
			if (e < t[0]) return t[0];
			for (; r <= n;) {
				if (s = r + Math.floor((n - r) / 2), s === i || e >= t[s] && e < t[s + 1]) return t[s];
				t[s] < e ? r = s + 1 : n = s - 1
			}
		}
		_adjustStashSize(e) {
			let t = 0;
			this._config.isLive || e < 512 ? t = e : e >= 512 && e <= 1024 ? t = Math.floor(e * 1.5) : t = e * 2, t > 8192 && (t = 8192);
			let i = t * 1024 + 1024 * 1024 * 1;
			this._bufferSize < i && this._expandBuffer(i), this._stashSize = t * 1024
		}
		_dispatchChunks(e, t) {
			return this._currentRange.to = t + e.byteLength - 1, this._onDataArrival(e, t)
		}
		_onURLRedirect(e) {
			this._redirectedURL = e, this._onRedirect && this._onRedirect(e)
		}
		_onContentLengthKnown(e) {
			e && this._fullRequestFlag && (this._totalLength = e, this._fullRequestFlag = !1)
		}
		_onLoaderChunkArrival(e, t, i) {
			if (!this._onDataArrival) throw new G("IOController: No existing consumer (onDataArrival) callback!");
			if (this._paused) return;
			this._isEarlyEofReconnecting && (this._isEarlyEofReconnecting = !1, this._onRecoveredEarlyEof && this._onRecoveredEarlyEof()), this._speedSampler.addBytes(e.byteLength);
			let s = this._speedSampler.lastSecondKBps;
			if (s !== 0) {
				let r = this._normalizeSpeed(s);
				this._speedNormalized !== r && (this._speedNormalized = r, this._adjustStashSize(r))
			}
			if (this._enableStash)
				if (this._stashUsed === 0 && this._stashByteStart === 0 && (this._stashByteStart = t), this._stashUsed + e.byteLength <= this._stashSize) new Uint8Array(this._stashBuffer, 0, this._stashSize).set(new Uint8Array(e), this._stashUsed), this._stashUsed += e.byteLength;
				else {
					let r = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
					if (this._stashUsed > 0) {
						let n = this._stashBuffer.slice(0, this._stashUsed),
							A = this._dispatchChunks(n, this._stashByteStart);
						if (A < n.byteLength) {
							if (A > 0) {
								let h = new Uint8Array(n, A);
								r.set(h, 0), this._stashUsed = h.byteLength, this._stashByteStart += A
							}
						} else this._stashUsed = 0, this._stashByteStart += A;
						this._stashUsed + e.byteLength > this._bufferSize && (this._expandBuffer(this._stashUsed + e.byteLength), r = new Uint8Array(this._stashBuffer, 0, this._bufferSize)), r.set(new Uint8Array(e), this._stashUsed), this._stashUsed += e.byteLength
					} else {
						let n = this._dispatchChunks(e, t);
						if (n < e.byteLength) {
							let A = e.byteLength - n;
							A > this._bufferSize && (this._expandBuffer(A), r = new Uint8Array(this._stashBuffer, 0, this._bufferSize)), r.set(new Uint8Array(e, n), 0), this._stashUsed += A, this._stashByteStart = t + n
						}
					}
				}
			else if (this._stashUsed === 0) {
				let r = this._dispatchChunks(e, t);
				if (r < e.byteLength) {
					let n = e.byteLength - r;
					n > this._bufferSize && this._expandBuffer(n), new Uint8Array(this._stashBuffer, 0, this._bufferSize).set(new Uint8Array(e, r), 0), this._stashUsed += n, this._stashByteStart = t + r
				}
			} else {
				this._stashUsed + e.byteLength > this._bufferSize && this._expandBuffer(this._stashUsed + e.byteLength);
				let r = new Uint8Array(this._stashBuffer, 0, this._bufferSize);
				r.set(new Uint8Array(e), this._stashUsed), this._stashUsed += e.byteLength;
				let n = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);
				if (n < this._stashUsed && n > 0) {
					let A = new Uint8Array(this._stashBuffer, n);
					r.set(A, 0)
				}
				this._stashUsed -= n, this._stashByteStart += n
			}
		}
		_flushStashBuffer(e) {
			if (this._stashUsed > 0) {
				let t = this._stashBuffer.slice(0, this._stashUsed),
					i = this._dispatchChunks(t, this._stashByteStart),
					s = t.byteLength - i;
				if (i < t.byteLength)
					if (e) o.w(this.TAG, `${s} bytes unconsumed data remain when flush buffer, dropped`);
					else {
						if (i > 0) {
							let r = new Uint8Array(this._stashBuffer, 0, this._bufferSize),
								n = new Uint8Array(t, i);
							r.set(n, 0), this._stashUsed = n.byteLength, this._stashByteStart += i
						}
						return 0
					} return this._stashUsed = 0, this._stashByteStart = 0, s
			}
			return 0
		}
		_onLoaderComplete(e, t) {
			this._flushStashBuffer(!0), this._onComplete && this._onComplete(this._extraData)
		}
		_onLoaderError(e, t) {
			switch (o.e(this.TAG, `Loader error, code = ${t.code}, msg = ${t.msg}`), this._flushStashBuffer(!1), this._isEarlyEofReconnecting && (this._isEarlyEofReconnecting = !1, e = T.UNRECOVERABLE_EARLY_EOF), e) {
				case T.EARLY_EOF: {
					if (!this._config.isLive && this._totalLength) {
						let i = this._currentRange.to + 1;
						i < this._totalLength && (o.w(this.TAG, "Connection lost, trying reconnect..."), this._isEarlyEofReconnecting = !0, this._internalSeek(i, !1));
						return
					}
					e = T.UNRECOVERABLE_EARLY_EOF;
					break
				}
			}
			if (this._onError) this._onError(e, t);
			else throw new P("IOException: " + t.msg)
		}
	}
	const Me = {
		enableWorker: !1,
		enableStashBuffer: !0,
		stashInitialSize: void 0,
		isLive: !1,
		lazyLoad: !0,
		lazyLoadMaxDuration: 3 * 60,
		lazyLoadRecoverDuration: 30,
		deferLoadAfterSourceOpen: !0,
		autoCleanupMaxBackwardDuration: 3 * 60,
		autoCleanupMinBackwardDuration: 2 * 60,
		statisticsInfoReportInterval: 600,
		fixAudioTimestampGap: !0,
		accurateSeek: !1,
		seekType: "range",
		seekParamStart: "bstart",
		seekParamEnd: "bend",
		rangeLoadZeroStart: !1,
		customSeekHandler: void 0,
		reuseRedirectedURL: !1,
		headers: void 0,
		customLoader: void 0
	};

	function se() {
		return Object.assign({}, Me)
	}
	class re {
		static supportMSEH264Playback() {
			return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"')
		}
		static supportNetworkStreamIO() {
			let e = new fe({}, se()),
				t = e.loaderType;
			return e.destroy(), t == "fetch-stream-loader" || t == "xhr-moz-chunked-loader"
		}
		static getNetworkLoaderTypeName() {
			let e = new fe({}, se()),
				t = e.loaderType;
			return e.destroy(), t
		}
		static supportNativeMediaPlayback(e) {
			re.videoElement == null && (re.videoElement = window.document.createElement("video"));
			let t = re.videoElement.canPlayType(e);
			return t === "probably" || t == "maybe"
		}
	}
	class tt extends y {
		constructor() {
			super();
			this.TAG = "WebLoader", this._config = se(), this._loader = null, this._loaderClass = null, this._seekHandler = null, this._isStart = !1, this._isFirst = !0
		}
		start(e) {
			if (this._isStart) throw "isStart";
			this._isWebSocketURL = /wss?:\/\/(.+?)/.test(e), this._currentRange = {
				from: 0,
				to: -1
			}, this._selectSeekHandler(), this._selectLoader(), this._createLoader(), this._loader.open({
				url: e
			}, Object.assign({}, this._currentRange)), this._isStart = !0, this._isFirst = !0
		}
		stop() {
			this._isStart && (this._loader.abort(), this._isStart = !1)
		}
		_selectSeekHandler() {
			let e = this._config;
			if (e.seekType === "range") this._seekHandler = new Be(this._config.rangeLoadZeroStart);
			else if (e.seekType === "param") {
				let t = e.seekParamStart || "bstart",
					i = e.seekParamEnd || "bend";
				this._seekHandler = new Ce(t, i)
			} else if (e.seekType === "custom") {
				if (typeof e.customSeekHandler != "function") throw new j("Custom seekType specified in config but invalid customSeekHandler!");
				this._seekHandler = new e.customSeekHandler
			} else throw new j(`Invalid seekType in config: ${e.seekType}`)
		}
		_selectLoader() {
			if (this._isWebSocketURL) this._loaderClass = Se;
			else if (ae.isSupported()) this._loaderClass = ae;
			else if (oe.isSupported()) this._loaderClass = oe;
			else if (ie.isSupported()) this._loaderClass = ie;
			else throw new P("Your browser doesn't support xhr with arraybuffer responseType!")
		}
		_createLoader() {
			this._loader = new this._loaderClass(this._seekHandler, this._config), this._loader.onContentLength = this._onContentLength.bind(this), this._loader.onURLRedirect = this._onURLRedirect.bind(this), this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this), this._loader.onComplete = this._onLoaderComplete.bind(this), this._loader.onError = this._onLoaderError.bind(this)
		}
		_onURLRedirect() {}
		_onContentLength(e) {}
		_onLoaderChunkArrival(e, t, i) {
			this._isFirst && (this.emit("start"), this._isFirst = !1), this.emit("data", e)
		}
		_onLoaderComplete(e, t) {
			this.emit("close"), this._isFirst = !0
		}
		_onLoaderError(e, t) {
			this.emit("error", t), this._isFirst = !0
		}
	}
	const v = {
		ERROR: "error",
		LOADING_COMPLETE: "loading_complete",
		RECOVERED_EARLY_EOF: "recovered_early_eof",
		MEDIA_INFO: "media_info",
		METADATA_ARRIVED: "metadata_arrived",
		SCRIPTDATA_ARRIVED: "scriptdata_arrived",
		STATISTICS_INFO: "statistics_info"
	};
	class O {
		static get forceGlobalTag() {
			return o.FORCE_GLOBAL_TAG
		}
		static set forceGlobalTag(e) {
			o.FORCE_GLOBAL_TAG = e, O._notifyChange()
		}
		static get globalTag() {
			return o.GLOBAL_TAG
		}
		static set globalTag(e) {
			o.GLOBAL_TAG = e, O._notifyChange()
		}
		static get enableAll() {
			return o.ENABLE_VERBOSE && o.ENABLE_DEBUG && o.ENABLE_INFO && o.ENABLE_WARN && o.ENABLE_ERROR
		}
		static set enableAll(e) {
			o.ENABLE_VERBOSE = e, o.ENABLE_DEBUG = e, o.ENABLE_INFO = e, o.ENABLE_WARN = e, o.ENABLE_ERROR = e, O._notifyChange()
		}
		static get enableDebug() {
			return o.ENABLE_DEBUG
		}
		static set enableDebug(e) {
			o.ENABLE_DEBUG = e, O._notifyChange()
		}
		static get enableVerbose() {
			return o.ENABLE_VERBOSE
		}
		static set enableVerbose(e) {
			o.ENABLE_VERBOSE = e, O._notifyChange()
		}
		static get enableInfo() {
			return o.ENABLE_INFO
		}
		static set enableInfo(e) {
			o.ENABLE_INFO = e, O._notifyChange()
		}
		static get enableWarn() {
			return o.ENABLE_WARN
		}
		static set enableWarn(e) {
			o.ENABLE_WARN = e, O._notifyChange()
		}
		static get enableError() {
			return o.ENABLE_ERROR
		}
		static set enableError(e) {
			o.ENABLE_ERROR = e, O._notifyChange()
		}
		static getConfig() {
			return {
				globalTag: o.GLOBAL_TAG,
				forceGlobalTag: o.FORCE_GLOBAL_TAG,
				enableVerbose: o.ENABLE_VERBOSE,
				enableDebug: o.ENABLE_DEBUG,
				enableInfo: o.ENABLE_INFO,
				enableWarn: o.ENABLE_WARN,
				enableError: o.ENABLE_ERROR,
				enableCallback: o.ENABLE_CALLBACK
			}
		}
		static applyConfig(e) {
			o.GLOBAL_TAG = e.globalTag, o.FORCE_GLOBAL_TAG = e.forceGlobalTag, o.ENABLE_VERBOSE = e.enableVerbose, o.ENABLE_DEBUG = e.enableDebug, o.ENABLE_INFO = e.enableInfo, o.ENABLE_WARN = e.enableWarn, o.ENABLE_ERROR = e.enableError, o.ENABLE_CALLBACK = e.enableCallback
		}
		static _notifyChange() {
			let e = O.emitter;
			if (e.listenerCount("change") > 0) {
				let t = O.getConfig();
				e.emit("change", t)
			}
		}
		static registerListener(e) {
			O.emitter.addListener("change", e)
		}
		static removeListener(e) {
			O.emitter.removeListener("change", e)
		}
		static addLogListener(e) {
			o.emitter.addListener("log", e), o.emitter.listenerCount("log") > 0 && (o.ENABLE_CALLBACK = !0, O._notifyChange())
		}
		static removeLogListener(e) {
			o.emitter.removeListener("log", e), o.emitter.listenerCount("log") === 0 && (o.ENABLE_CALLBACK = !1, O._notifyChange())
		}
	}
	O.emitter = new y;
	class le {
		constructor() {
			this.mimeType = null, this.duration = null, this.hasAudio = null, this.hasVideo = null, this.audioCodec = null, this.videoCodec = null, this.audioDataRate = null, this.videoDataRate = null, this.audioSampleRate = null, this.audioChannelCount = null, this.width = null, this.height = null, this.fps = null, this.profile = null, this.level = null, this.refFrames = null, this.chromaFormat = null, this.sarNum = null, this.sarDen = null, this.metadata = null, this.segments = null, this.segmentCount = null, this.hasKeyframesIndex = null, this.keyframesIndex = null
		}
		isComplete() {
			let e = this.hasAudio === !1 || this.hasAudio === !0 && this.audioCodec != null && this.audioSampleRate != null && this.audioChannelCount != null,
				t = this.hasVideo === !1 || this.hasVideo === !0 && this.videoCodec != null && this.width != null && this.height != null && this.fps != null && this.profile != null && this.level != null && this.refFrames != null && this.chromaFormat != null && this.sarNum != null && this.sarDen != null;
			return this.mimeType != null && this.duration != null && this.metadata != null && this.hasKeyframesIndex != null && e && t
		}
		isSeekable() {
			return this.hasKeyframesIndex === !0
		}
		getNearestKeyframe(e) {
			if (this.keyframesIndex == null) return null;
			let t = this.keyframesIndex,
				i = this._search(t.times, e);
			return {
				index: i,
				milliseconds: t.times[i],
				fileposition: t.filepositions[i]
			}
		}
		_search(e, t) {
			let i = 0,
				s = e.length - 1,
				r = 0,
				n = 0,
				A = s;
			for (t < e[0] && (i = 0, n = A + 1); n <= A;)
				if (r = n + Math.floor((A - n) / 2), r === s || t >= e[r] && t < e[r + 1]) {
					i = r;
					break
				} else e[r] < t ? n = r + 1 : A = r - 1;
			return i
		}
	}

	function _e(a, e, t) {
		let i = a;
		if (e + t < i.length) {
			for (; t--;)
				if ((i[++e] & 192) != 128) return !1;
			return !0
		} else return !1
	}

	function be(a) {
		let e = [],
			t = a,
			i = 0,
			s = a.length;
		for (; i < s;) {
			if (t[i] < 128) {
				e.push(String.fromCharCode(t[i])), ++i;
				continue
			} else if (!(t[i] < 192)) {
				if (t[i] < 224) {
					if (_e(t, i, 1)) {
						let r = (t[i] & 31) << 6 | t[i + 1] & 63;
						if (r >= 128) {
							e.push(String.fromCharCode(r & 65535)), i += 2;
							continue
						}
					}
				} else if (t[i] < 240) {
					if (_e(t, i, 2)) {
						let r = (t[i] & 15) << 12 | (t[i + 1] & 63) << 6 | t[i + 2] & 63;
						if (r >= 2048 && (r & 63488) != 55296) {
							e.push(String.fromCharCode(r & 65535)), i += 3;
							continue
						}
					}
				} else if (t[i] < 248 && _e(t, i, 3)) {
					let r = (t[i] & 7) << 18 | (t[i + 1] & 63) << 12 | (t[i + 2] & 63) << 6 | t[i + 3] & 63;
					if (r > 65536 && r < 1114112) {
						r -= 65536, e.push(String.fromCharCode(r >>> 10 | 55296)), e.push(String.fromCharCode(r & 1023 | 56320)), i += 4;
						continue
					}
				}
			}
			e.push(String.fromCharCode(65533)), ++i
		}
		return e.join("")
	}
	let z = function() {
		let a = new ArrayBuffer(2);
		return new DataView(a).setInt16(0, 256, !0), new Int16Array(a)[0] === 256
	}();
	class H {
		static parseScriptData(e, t, i) {
			let s = {};
			try {
				let r = H.parseValue(e, t, i),
					n = H.parseValue(e, t + r.size, i - r.size);
				s[r.data] = n.data
			} catch (r) {
				o.e("AMF", r.toString())
			}
			return s
		}
		static parseObject(e, t, i) {
			if (i < 3) throw new G("Data not enough when parse ScriptDataObject");
			let s = H.parseString(e, t, i),
				r = H.parseValue(e, t + s.size, i - s.size),
				n = r.objectEnd;
			return {
				data: {
					name: s.data,
					value: r.data
				},
				size: s.size + r.size,
				objectEnd: n
			}
		}
		static parseVariable(e, t, i) {
			return H.parseObject(e, t, i)
		}
		static parseString(e, t, i) {
			if (i < 2) throw new G("Data not enough when parse String");
			let r = new DataView(e, t, i).getUint16(0, !z),
				n;
			return r > 0 ? n = be(new Uint8Array(e, t + 2, r)) : n = "", {
				data: n,
				size: 2 + r
			}
		}
		static parseLongString(e, t, i) {
			if (i < 4) throw new G("Data not enough when parse LongString");
			let r = new DataView(e, t, i).getUint32(0, !z),
				n;
			return r > 0 ? n = be(new Uint8Array(e, t + 4, r)) : n = "", {
				data: n,
				size: 4 + r
			}
		}
		static parseDate(e, t, i) {
			if (i < 10) throw new G("Data size invalid when parse Date");
			let s = new DataView(e, t, i),
				r = s.getFloat64(0, !z);
			return r += s.getInt16(8, !z) * 60 * 1e3, {
				data: new Date(r),
				size: 8 + 2
			}
		}
		static parseValue(e, t, i) {
			if (i < 1) throw new G("Data not enough when parse Value");
			let s = new DataView(e, t, i),
				r = 1,
				n = s.getUint8(0),
				A, h = !1;
			try {
				switch (n) {
					case 0:
						A = s.getFloat64(1, !z), r += 8;
						break;
					case 1: {
						A = !!s.getUint8(1), r += 1;
						break
					}
					case 2: {
						let d = H.parseString(e, t + 1, i - 1);
						A = d.data, r += d.size;
						break
					}
					case 3: {
						A = {};
						let d = 0;
						for ((s.getUint32(i - 4, !z) & 16777215) == 9 && (d = 3); r < i - 4;) {
							let _ = H.parseObject(e, t + r, i - r - d);
							if (_.objectEnd) break;
							A[_.data.name] = _.data.value, r += _.size
						}
						r <= i - 3 && (s.getUint32(r - 1, !z) & 16777215) === 9 && (r += 3);
						break
					}
					case 8: {
						A = {}, r += 4;
						let d = 0;
						for ((s.getUint32(i - 4, !z) & 16777215) == 9 && (d = 3); r < i - 8;) {
							let _ = H.parseVariable(e, t + r, i - r - d);
							if (_.objectEnd) break;
							A[_.data.name] = _.data.value, r += _.size
						}
						r <= i - 3 && (s.getUint32(r - 1, !z) & 16777215) === 9 && (r += 3);
						break
					}
					case 9:
						A = void 0, r = 1, h = !0;
						break;
					case 10: {
						A = [];
						let d = s.getUint32(1, !z);
						r += 4;
						for (let _ = 0; _ < d; _++) {
							let S = H.parseValue(e, t + r, i - r);
							A.push(S.data), r += S.size
						}
						break
					}
					case 11: {
						let d = H.parseDate(e, t + 1, i - 1);
						A = d.data, r += d.size;
						break
					}
					case 12: {
						let d = H.parseString(e, t + 1, i - 1);
						A = d.data, r += d.size;
						break
					}
					default:
						r = i, o.w("AMF", "Unsupported AMF value type " + n)
				}
			} catch (d) {
				o.e("AMF", d.toString())
			}
			return {
				data: A,
				size: r,
				objectEnd: h
			}
		}
	}
	class Ne {
		constructor(e) {
			this.TAG = "ExpGolomb", this._buffer = e, this._buffer_index = 0, this._total_bytes = e.byteLength, this._total_bits = e.byteLength * 8, this._current_word = 0, this._current_word_bits_left = 0
		}
		destroy() {
			this._buffer = null
		}
		_fillCurrentWord() {
			let e = this._total_bytes - this._buffer_index;
			if (e <= 0) throw new G("ExpGolomb: _fillCurrentWord() but no bytes available");
			let t = Math.min(4, e),
				i = new Uint8Array(4);
			i.set(this._buffer.subarray(this._buffer_index, this._buffer_index + t)), this._current_word = new DataView(i.buffer).getUint32(0, !1), this._buffer_index += t, this._current_word_bits_left = t * 8
		}
		readBits(e) {
			if (e > 32) throw new j("ExpGolomb: readBits() bits exceeded max 32bits!");
			if (e <= this._current_word_bits_left) {
				let n = this._current_word >>> 32 - e;
				return this._current_word <<= e, this._current_word_bits_left -= e, n
			}
			let t = this._current_word_bits_left ? this._current_word : 0;
			t = t >>> 32 - this._current_word_bits_left;
			let i = e - this._current_word_bits_left;
			this._fillCurrentWord();
			let s = Math.min(i, this._current_word_bits_left),
				r = this._current_word >>> 32 - s;
			return this._current_word <<= s, this._current_word_bits_left -= s, t = t << s | r, t
		}
		readBool() {
			return this.readBits(1) === 1
		}
		readByte() {
			return this.readBits(8)
		}
		_skipLeadingZero() {
			let e;
			for (e = 0; e < this._current_word_bits_left; e++)
				if ((this._current_word & 2147483648 >>> e) != 0) return this._current_word <<= e, this._current_word_bits_left -= e, e;
			return this._fillCurrentWord(), e + this._skipLeadingZero()
		}
		readUEG() {
			let e = this._skipLeadingZero();
			return this.readBits(e + 1) - 1
		}
		readSEG() {
			let e = this.readUEG();
			return e & 1 ? e + 1 >>> 1 : -1 * (e >>> 1)
		}
	}
	class K {
		static _ebsp2rbsp(e) {
			let t = e,
				i = t.byteLength,
				s = new Uint8Array(i),
				r = 0;
			for (let n = 0; n < i; n++) n >= 2 && t[n] === 3 && t[n - 1] === 0 && t[n - 2] === 0 || (s[r] = t[n], r++);
			return new Uint8Array(s.buffer, 0, r)
		}
		static parseSPS(e) {
			let t = K._ebsp2rbsp(e),
				i = new Ne(t);
			i.readByte();
			let s = i.readByte();
			i.readByte();
			let r = i.readByte();
			i.readUEG();
			let n = K.getProfileString(s),
				A = K.getLevelString(r),
				h = 1,
				d = 420,
				_ = [0, 420, 422, 444],
				S = 8;
			if ((s === 100 || s === 110 || s === 122 || s === 244 || s === 44 || s === 83 || s === 86 || s === 118 || s === 128 || s === 138 || s === 144) && (h = i.readUEG(), h === 3 && i.readBits(1), h <= 3 && (d = _[h]), S = i.readUEG() + 8, i.readUEG(), i.readBits(1), i.readBool())) {
				let M = h !== 3 ? 8 : 12;
				for (let N = 0; N < M; N++) i.readBool() && (N < 6 ? K._skipScalingList(i, 16) : K._skipScalingList(i, 64))
			}
			i.readUEG();
			let u = i.readUEG();
			if (u === 0) i.readUEG();
			else if (u === 1) {
				i.readBits(1), i.readSEG(), i.readSEG();
				let M = i.readUEG();
				for (let N = 0; N < M; N++) i.readSEG()
			}
			let B = i.readUEG();
			i.readBits(1);
			let f = i.readUEG(),
				m = i.readUEG(),
				c = i.readBits(1);
			c === 0 && i.readBits(1), i.readBits(1);
			let p = 0,
				x = 0,
				b = 0,
				I = 0;
			i.readBool() && (p = i.readUEG(), x = i.readUEG(), b = i.readUEG(), I = i.readUEG());
			let C = 1,
				g = 1,
				U = 0,
				F = !0,
				L = 0,
				k = 0;
			if (i.readBool()) {
				if (i.readBool()) {
					let M = i.readByte(),
						N = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2],
						ue = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
					M > 0 && M < 16 ? (C = N[M - 1], g = ue[M - 1]) : M === 255 && (C = i.readByte() << 8 | i.readByte(), g = i.readByte() << 8 | i.readByte())
				}
				if (i.readBool() && i.readBool(), i.readBool() && (i.readBits(4), i.readBool() && i.readBits(24)), i.readBool() && (i.readUEG(), i.readUEG()), i.readBool()) {
					let M = i.readBits(32),
						N = i.readBits(32);
					F = i.readBool(), L = N, k = M * 2, U = L / k
				}
			}
			let Y = 1;
			(C !== 1 || g !== 1) && (Y = C / g);
			let J = 0,
				$ = 0;
			if (h === 0) J = 1, $ = 2 - c;
			else {
				let M = h === 3 ? 1 : 2,
					N = h === 1 ? 2 : 1;
				J = M, $ = N * (2 - c)
			}
			let ee = (f + 1) * 16,
				X = (2 - c) * ((m + 1) * 16);
			ee -= (p + x) * J, X -= (b + I) * $;
			let de = Math.ceil(ee * Y);
			return i.destroy(), i = null, {
				profile_string: n,
				level_string: A,
				bit_depth: S,
				ref_frames: B,
				chroma_format: d,
				chroma_format_string: K.getChromaFormatString(d),
				frame_rate: {
					fixed: F,
					fps: U,
					fps_den: k,
					fps_num: L
				},
				sar_ratio: {
					width: C,
					height: g
				},
				codec_size: {
					width: ee,
					height: X
				},
				present_size: {
					width: de,
					height: X
				}
			}
		}
		static _skipScalingList(e, t) {
			let i = 8,
				s = 8,
				r = 0;
			for (let n = 0; n < t; n++) s !== 0 && (r = e.readSEG(), s = (i + r + 256) % 256), i = s === 0 ? i : s
		}
		static getProfileString(e) {
			switch (e) {
				case 66:
					return "Baseline";
				case 77:
					return "Main";
				case 88:
					return "Extended";
				case 100:
					return "High";
				case 110:
					return "High10";
				case 122:
					return "High422";
				case 244:
					return "High444";
				default:
					return "Unknown"
			}
		}
		static getLevelString(e) {
			return (e / 10).toFixed(1)
		}
		static getChromaFormatString(e) {
			switch (e) {
				case 420:
					return "4:2:0";
				case 422:
					return "4:2:2";
				case 444:
					return "4:4:4";
				default:
					return "Unknown"
			}
		}
	}
	const Q = {
		OK: "OK",
		FORMAT_ERROR: "FormatError",
		FORMAT_UNSUPPORTED: "FormatUnsupported",
		CODEC_UNSUPPORTED: "CodecUnsupported"
	};

	function Ge(a, e) {
		return a[e] << 24 | a[e + 1] << 16 | a[e + 2] << 8 | a[e + 3]
	}
	class he {
		constructor(e, t) {
			this.TAG = "FLVDemuxer", this._config = t, this._onError = null, this._onMediaInfo = null, this._onMetaDataArrived = null, this._onScriptDataArrived = null, this._onTrackMetadata = null, this._onDataAvailable = null, this._dataOffset = e.dataOffset, this._firstParse = !0, this._dispatch = !1, this._hasAudio = e.hasAudioTrack, this._hasVideo = e.hasVideoTrack, this._hasAudioFlagOverrided = !1, this._hasVideoFlagOverrided = !1, this._audioInitialMetadataDispatched = !1, this._videoInitialMetadataDispatched = !1, this._mediaInfo = new le, this._mediaInfo.hasAudio = this._hasAudio, this._mediaInfo.hasVideo = this._hasVideo, this._metadata = null, this._audioMetadata = null, this._videoMetadata = null, this._naluLengthSize = 4, this._timestampBase = 0, this._timescale = 1e3, this._duration = 0, this._durationOverrided = !1, this._referenceFrameRate = {
				fixed: !0,
				fps: 23.976,
				fps_num: 23976,
				fps_den: 1e3
			}, this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48e3], this._mpegSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], this._mpegAudioV10SampleRateTable = [44100, 48e3, 32e3, 0], this._mpegAudioV20SampleRateTable = [22050, 24e3, 16e3, 0], this._mpegAudioV25SampleRateTable = [11025, 12e3, 8e3, 0], this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1], this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1], this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1], this._videoTrack = {
				type: "video",
				id: 1,
				sequenceNumber: 0,
				samples: [],
				length: 0
			}, this._audioTrack = {
				type: "audio",
				id: 2,
				sequenceNumber: 0,
				samples: [],
				length: 0
			}, this._littleEndian = function() {
				let i = new ArrayBuffer(2);
				return new DataView(i).setInt16(0, 256, !0), new Int16Array(i)[0] === 256
			}()
		}
		destroy() {
			this._mediaInfo = null, this._metadata = null, this._audioMetadata = null, this._videoMetadata = null, this._videoTrack = null, this._audioTrack = null, this._onError = null, this._onMediaInfo = null, this._onMetaDataArrived = null, this._onScriptDataArrived = null, this._onTrackMetadata = null, this._onDataAvailable = null
		}
		static probe(e) {
			let t = new Uint8Array(e),
				i = {
					match: !1
				};
			if (t[0] !== 70 || t[1] !== 76 || t[2] !== 86 || t[3] !== 1) return i;
			let s = (t[4] & 4) >>> 2 != 0,
				r = (t[4] & 1) != 0,
				n = Ge(t, 5);
			return n < 9 ? i : {
				match: !0,
				consumed: n,
				dataOffset: n,
				hasAudioTrack: s,
				hasVideoTrack: r
			}
		}
		bindDataSource(e) {
			return e.onDataArrival = this.parseChunks.bind(this), this
		}
		get onTrackMetadata() {
			return this._onTrackMetadata
		}
		set onTrackMetadata(e) {
			this._onTrackMetadata = e
		}
		get onMediaInfo() {
			return this._onMediaInfo
		}
		set onMediaInfo(e) {
			this._onMediaInfo = e
		}
		get onMetaDataArrived() {
			return this._onMetaDataArrived
		}
		set onMetaDataArrived(e) {
			this._onMetaDataArrived = e
		}
		get onScriptDataArrived() {
			return this._onScriptDataArrived
		}
		set onScriptDataArrived(e) {
			this._onScriptDataArrived = e
		}
		get onError() {
			return this._onError
		}
		set onError(e) {
			this._onError = e
		}
		get onDataAvailable() {
			return this._onDataAvailable
		}
		set onDataAvailable(e) {
			this._onDataAvailable = e
		}
		get timestampBase() {
			return this._timestampBase
		}
		set timestampBase(e) {
			this._timestampBase = e
		}
		get overridedDuration() {
			return this._duration
		}
		set overridedDuration(e) {
			this._durationOverrided = !0, this._duration = e, this._mediaInfo.duration = e
		}
		set overridedHasAudio(e) {
			this._hasAudioFlagOverrided = !0, this._hasAudio = e, this._mediaInfo.hasAudio = e
		}
		set overridedHasVideo(e) {
			this._hasVideoFlagOverrided = !0, this._hasVideo = e, this._mediaInfo.hasVideo = e
		}
		resetMediaInfo() {
			this._mediaInfo = new le
		}
		_isInitialMetadataDispatched() {
			return this._hasAudio && this._hasVideo ? this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched : this._hasAudio && !this._hasVideo ? this._audioInitialMetadataDispatched : !this._hasAudio && this._hasVideo ? this._videoInitialMetadataDispatched : !1
		}
		parseChunks(e, t) {
			if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) throw new G("Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified");
			let i = 0,
				s = this._littleEndian;
			if (t === 0)
				if (e.byteLength > 13) i = he.probe(e).dataOffset;
				else return 0;
			for (this._firstParse && (this._firstParse = !1, t + i !== this._dataOffset && o.w(this.TAG, "First time parsing but chunk byteStart invalid!"), new DataView(e, i).getUint32(0, !s) !== 0 && o.w(this.TAG, "PrevTagSize0 !== 0 !!!"), i += 4); i < e.byteLength;) {
				this._dispatch = !0;
				let r = new DataView(e, i);
				if (i + 11 + 4 > e.byteLength) break;
				let n = r.getUint8(0),
					A = r.getUint32(0, !s) & 16777215;
				if (i + 11 + A + 4 > e.byteLength) break;
				if (n !== 8 && n !== 9 && n !== 18) {
					o.w(this.TAG, `Unsupported tag type ${n}, skipped`), i += 11 + A + 4;
					continue
				}
				let h = r.getUint8(4),
					d = r.getUint8(5),
					_ = r.getUint8(6),
					S = r.getUint8(7),
					u = _ | d << 8 | h << 16 | S << 24;
				(r.getUint32(7, !s) & 16777215) !== 0 && o.w(this.TAG, "Meet tag which has StreamID != 0!");
				let f = i + 11;
				switch (n) {
					case 8:
						this._parseAudioData(e, f, A, u);
						break;
					case 9:
						this._parseVideoData(e, f, A, u, t + i);
						break;
					case 18:
						this._parseScriptData(e, f, A);
						break
				}
				let m = r.getUint32(11 + A, !s);
				m !== 11 + A && o.w(this.TAG, `Invalid PrevTagSize ${m}`), i += 11 + A + 4
			}
			return this._isInitialMetadataDispatched() && this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack), i
		}
		_parseScriptData(e, t, i) {
			let s = H.parseScriptData(e, t, i);
			if (s.hasOwnProperty("onMetaData")) {
				if (s.onMetaData == null || typeof s.onMetaData != "object") {
					o.w(this.TAG, "Invalid onMetaData structure!");
					return
				}
				this._metadata && o.w(this.TAG, "Found another onMetaData tag!"), this._metadata = s;
				let r = this._metadata.onMetaData;
				if (this._onMetaDataArrived && this._onMetaDataArrived(Object.assign({}, r)), typeof r.hasAudio == "boolean" && this._hasAudioFlagOverrided === !1 && (this._hasAudio = r.hasAudio, this._mediaInfo.hasAudio = this._hasAudio), typeof r.hasVideo == "boolean" && this._hasVideoFlagOverrided === !1 && (this._hasVideo = r.hasVideo, this._mediaInfo.hasVideo = this._hasVideo), typeof r.audiodatarate == "number" && (this._mediaInfo.audioDataRate = r.audiodatarate), typeof r.videodatarate == "number" && (this._mediaInfo.videoDataRate = r.videodatarate), typeof r.width == "number" && (this._mediaInfo.width = r.width), typeof r.height == "number" && (this._mediaInfo.height = r.height), typeof r.duration == "number") {
					if (!this._durationOverrided) {
						let n = Math.floor(r.duration * this._timescale);
						this._duration = n, this._mediaInfo.duration = n
					}
				} else this._mediaInfo.duration = 0;
				if (typeof r.framerate == "number") {
					let n = Math.floor(r.framerate * 1e3);
					if (n > 0) {
						let A = n / 1e3;
						this._referenceFrameRate.fixed = !0, this._referenceFrameRate.fps = A, this._referenceFrameRate.fps_num = n, this._referenceFrameRate.fps_den = 1e3, this._mediaInfo.fps = A
					}
				}
				if (typeof r.keyframes == "object") {
					this._mediaInfo.hasKeyframesIndex = !0;
					let n = r.keyframes;
					this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(n), r.keyframes = null
				} else this._mediaInfo.hasKeyframesIndex = !1;
				this._dispatch = !1, this._mediaInfo.metadata = r, o.v(this.TAG, "Parsed onMetaData"), this._mediaInfo.isComplete() && this._onMediaInfo(this._mediaInfo)
			}
			Object.keys(s).length > 0 && this._onScriptDataArrived && this._onScriptDataArrived(Object.assign({}, s))
		}
		_parseKeyframesIndex(e) {
			let t = [],
				i = [];
			for (let s = 1; s < e.times.length; s++) {
				let r = this._timestampBase + Math.floor(e.times[s] * 1e3);
				t.push(r), i.push(e.filepositions[s])
			}
			return {
				times: t,
				filepositions: i
			}
		}
		_parseAudioData(e, t, i, s) {
			if (i <= 1) {
				o.w(this.TAG, "Flv: Invalid audio packet, missing SoundData payload!");
				return
			}
			if (this._hasAudioFlagOverrided === !0 && this._hasAudio === !1) return;
			let r = this._littleEndian,
				A = new DataView(e, t, i).getUint8(0),
				h = A >>> 4;
			if (h !== 2 && h !== 10) {
				this._onError(Q.CODEC_UNSUPPORTED, "Flv: Unsupported audio codec idx: " + h);
				return
			}
			let d = 0,
				_ = (A & 12) >>> 2;
			if (_ >= 0 && _ <= 4) d = this._flvSoundRateTable[_];
			else {
				this._onError(Q.FORMAT_ERROR, "Flv: Invalid audio sample rate idx: " + _);
				return
			}
			let S = A & 1,
				u = this._audioMetadata,
				B = this._audioTrack;
			if (u || (this._hasAudio === !1 && this._hasAudioFlagOverrided === !1 && (this._hasAudio = !0, this._mediaInfo.hasAudio = !0), u = this._audioMetadata = {}, u.type = "audio", u.id = B.id, u.timescale = this._timescale, u.duration = this._duration, u.audioSampleRate = d, u.channelCount = S === 0 ? 1 : 2), h === 10) {
				let f = this._parseAACAudioData(e, t + 1, i - 1);
				if (f == null) return;
				if (f.packetType === 0) {
					u.config && o.w(this.TAG, "Found another AudioSpecificConfig!");
					let m = f.data;
					u.audioSampleRate = m.samplingRate, u.channelCount = m.channelCount, u.codec = m.codec, u.originalCodec = m.originalCodec, u.config = m.config, u.refSampleDuration = 1024 / u.audioSampleRate * u.timescale, o.v(this.TAG, "Parsed AudioSpecificConfig"), this._isInitialMetadataDispatched() ? this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack) : this._audioInitialMetadataDispatched = !0, this._dispatch = !1, this._onTrackMetadata("audio", u);
					let c = this._mediaInfo;
					c.audioCodec = u.originalCodec, c.audioSampleRate = u.audioSampleRate, c.audioChannelCount = u.channelCount, c.hasVideo ? c.videoCodec != null && (c.mimeType = 'video/x-flv; codecs="' + c.videoCodec + "," + c.audioCodec + '"') : c.mimeType = 'video/x-flv; codecs="' + c.audioCodec + '"', c.isComplete() && this._onMediaInfo(c)
				} else if (f.packetType === 1) {
					let m = this._timestampBase + s,
						c = {
							unit: f.data,
							length: f.data.byteLength,
							dts: m,
							pts: m
						};
					B.samples.push(c), B.length += f.data.length
				} else o.e(this.TAG, `Flv: Unsupported AAC data type ${f.packetType}`)
			} else if (h === 2) {
				if (!u.codec) {
					let p = this._parseMP3AudioData(e, t + 1, i - 1, !0);
					if (p == null) return;
					u.audioSampleRate = p.samplingRate, u.channelCount = p.channelCount, u.codec = p.codec, u.originalCodec = p.originalCodec, u.refSampleDuration = 1152 / u.audioSampleRate * u.timescale, o.v(this.TAG, "Parsed MPEG Audio Frame Header"), this._audioInitialMetadataDispatched = !0, this._onTrackMetadata("audio", u);
					let x = this._mediaInfo;
					x.audioCodec = u.codec, x.audioSampleRate = u.audioSampleRate, x.audioChannelCount = u.channelCount, x.audioDataRate = p.bitRate, x.hasVideo ? x.videoCodec != null && (x.mimeType = 'video/x-flv; codecs="' + x.videoCodec + "," + x.audioCodec + '"') : x.mimeType = 'video/x-flv; codecs="' + x.audioCodec + '"', x.isComplete() && this._onMediaInfo(x)
				}
				let f = this._parseMP3AudioData(e, t + 1, i - 1, !1);
				if (f == null) return;
				let m = this._timestampBase + s,
					c = {
						unit: f,
						length: f.byteLength,
						dts: m,
						pts: m
					};
				B.samples.push(c), B.length += f.length
			}
		}
		_parseAACAudioData(e, t, i) {
			if (i <= 1) {
				o.w(this.TAG, "Flv: Invalid AAC packet, missing AACPacketType or/and Data!");
				return
			}
			let s = {},
				r = new Uint8Array(e, t, i);
			return s.packetType = r[0], r[0] === 0 ? s.data = this._parseAACAudioSpecificConfig(e, t + 1, i - 1) : s.data = r.subarray(1), s
		}
		_parseAACAudioSpecificConfig(e, t, i) {
			let s = new Uint8Array(e, t, i),
				r = null,
				n = 0,
				A = 0,
				h = 0,
				d = null;
			if (n = A = s[0] >>> 3, h = (s[0] & 7) << 1 | s[1] >>> 7, h < 0 || h >= this._mpegSamplingRates.length) {
				this._onError(Q.FORMAT_ERROR, "Flv: AAC invalid sampling frequency index!");
				return
			}
			let _ = this._mpegSamplingRates[h],
				S = (s[1] & 120) >>> 3;
			if (S < 0 || S >= 8) {
				this._onError(Q.FORMAT_ERROR, "Flv: AAC invalid channel configuration");
				return
			}
			n === 5 && (d = (s[1] & 7) << 1 | s[2] >>> 7);
			let u = self.navigator.userAgent.toLowerCase();
			return u.indexOf("firefox") !== -1 ? h >= 6 ? (n = 5, r = new Array(4), d = h - 3) : (n = 2, r = new Array(2), d = h) : u.indexOf("android") !== -1 ? (n = 2, r = new Array(2), d = h) : (n = 5, d = h, r = new Array(4), h >= 6 ? d = h - 3 : S === 1 && (n = 2, r = new Array(2), d = h)), r[0] = n << 3, r[0] |= (h & 15) >>> 1, r[1] = (h & 15) << 7, r[1] |= (S & 15) << 3, n === 5 && (r[1] |= (d & 15) >>> 1, r[2] = (d & 1) << 7, r[2] |= 2 << 2, r[3] = 0), {
				config: r,
				samplingRate: _,
				channelCount: S,
				codec: "mp4a.40." + n,
				originalCodec: "mp4a.40." + A
			}
		}
		_parseMP3AudioData(e, t, i, s) {
			if (i < 4) {
				o.w(this.TAG, "Flv: Invalid MP3 packet, header missing!");
				return
			}
			let r = this._littleEndian,
				n = new Uint8Array(e, t, i),
				A = null;
			if (s) {
				if (n[0] !== 255) return;
				let h = n[1] >>> 3 & 3,
					d = (n[1] & 6) >> 1,
					_ = (n[2] & 240) >>> 4,
					S = (n[2] & 12) >>> 2,
					B = (n[3] >>> 6 & 3) !== 3 ? 2 : 1,
					f = 0,
					m = 0,
					c = "mp3";
				switch (h) {
					case 0:
						f = this._mpegAudioV25SampleRateTable[S];
						break;
					case 2:
						f = this._mpegAudioV20SampleRateTable[S];
						break;
					case 3:
						f = this._mpegAudioV10SampleRateTable[S];
						break
				}
				switch (d) {
					case 1:
						_ < this._mpegAudioL3BitRateTable.length && (m = this._mpegAudioL3BitRateTable[_]);
						break;
					case 2:
						_ < this._mpegAudioL2BitRateTable.length && (m = this._mpegAudioL2BitRateTable[_]);
						break;
					case 3:
						_ < this._mpegAudioL1BitRateTable.length && (m = this._mpegAudioL1BitRateTable[_]);
						break
				}
				A = {
					bitRate: m,
					samplingRate: f,
					channelCount: B,
					codec: c,
					originalCodec: c
				}
			} else A = n;
			return A
		}
		_parseVideoData(e, t, i, s, r) {
			if (i <= 1) {
				o.w(this.TAG, "Flv: Invalid video packet, missing VideoData payload!");
				return
			}
			if (this._hasVideoFlagOverrided === !0 && this._hasVideo === !1) return;
			let n = new Uint8Array(e, t, i)[0],
				A = (n & 240) >>> 4,
				h = n & 15;
			if (h !== 7) {
				this._onError(Q.CODEC_UNSUPPORTED, `Flv: Unsupported codec in video frame: ${h}`);
				return
			}
			this._parseAVCVideoPacket(e, t + 1, i - 1, s, r, A)
		}
		_parseAVCVideoPacket(e, t, i, s, r, n) {
			if (i < 4) {
				o.w(this.TAG, "Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime");
				return
			}
			let A = this._littleEndian,
				h = new DataView(e, t, i),
				d = h.getUint8(0),
				S = (h.getUint32(0, !A) & 16777215) << 8 >> 8;
			if (d === 0) this._parseAVCDecoderConfigurationRecord(e, t + 4, i - 4);
			else if (d === 1) this._parseAVCVideoData(e, t + 4, i - 4, s, r, n, S);
			else if (d !== 2) {
				this._onError(Q.FORMAT_ERROR, `Flv: Invalid video packet type ${d}`);
				return
			}
		}
		_parseAVCDecoderConfigurationRecord(e, t, i) {
			if (i < 7) {
				o.w(this.TAG, "Flv: Invalid AVCDecoderConfigurationRecord, lack of data!");
				return
			}
			let s = this._videoMetadata,
				r = this._videoTrack,
				n = this._littleEndian,
				A = new DataView(e, t, i);
			s ? typeof s.avcc != "undefined" && o.w(this.TAG, "Found another AVCDecoderConfigurationRecord!") : (this._hasVideo === !1 && this._hasVideoFlagOverrided === !1 && (this._hasVideo = !0, this._mediaInfo.hasVideo = !0), s = this._videoMetadata = {}, s.type = "video", s.id = r.id, s.timescale = this._timescale, s.duration = this._duration);
			let h = A.getUint8(0),
				d = A.getUint8(1),
				_ = A.getUint8(2),
				S = A.getUint8(3);
			if (h !== 1 || d === 0) {
				this._onError(Q.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord");
				return
			}
			if (this._naluLengthSize = (A.getUint8(4) & 3) + 1, this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {
				this._onError(Q.FORMAT_ERROR, `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize-1}`);
				return
			}
			let u = A.getUint8(5) & 31;
			if (u === 0) {
				this._onError(Q.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No SPS");
				return
			} else u > 1 && o.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ${u}`);
			let B = 6;
			for (let m = 0; m < u; m++) {
				let c = A.getUint16(B, !n);
				if (B += 2, c === 0) continue;
				let p = new Uint8Array(e, t + B, c);
				B += c;
				let x = K.parseSPS(p);
				if (m !== 0) continue;
				s.codecWidth = x.codec_size.width, s.codecHeight = x.codec_size.height, s.presentWidth = x.present_size.width, s.presentHeight = x.present_size.height, s.profile = x.profile_string, s.level = x.level_string, s.bitDepth = x.bit_depth, s.chromaFormat = x.chroma_format, s.sarRatio = x.sar_ratio, s.frameRate = x.frame_rate, (x.frame_rate.fixed === !1 || x.frame_rate.fps_num === 0 || x.frame_rate.fps_den === 0) && (s.frameRate = this._referenceFrameRate);
				let b = s.frameRate.fps_den,
					I = s.frameRate.fps_num;
				s.refSampleDuration = s.timescale * (b / I);
				let V = p.subarray(1, 4),
					C = "avc1.";
				for (let U = 0; U < 3; U++) {
					let F = V[U].toString(16);
					F.length < 2 && (F = "0" + F), C += F
				}
				s.codec = C;
				let g = this._mediaInfo;
				g.width = s.codecWidth, g.height = s.codecHeight, g.fps = s.frameRate.fps, g.profile = s.profile, g.level = s.level, g.refFrames = x.ref_frames, g.chromaFormat = x.chroma_format_string, g.sarNum = s.sarRatio.width, g.sarDen = s.sarRatio.height, g.videoCodec = C, g.hasAudio ? g.audioCodec != null && (g.mimeType = 'video/x-flv; codecs="' + g.videoCodec + "," + g.audioCodec + '"') : g.mimeType = 'video/x-flv; codecs="' + g.videoCodec + '"', g.isComplete() && this._onMediaInfo(g)
			}
			let f = A.getUint8(B);
			if (f === 0) {
				this._onError(Q.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No PPS");
				return
			} else f > 1 && o.w(this.TAG, `Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ${f}`);
			B++;
			for (let m = 0; m < f; m++) {
				let c = A.getUint16(B, !n);
				B += 2, c !== 0 && (B += c)
			}
			s.avcc = new Uint8Array(i), s.avcc.set(new Uint8Array(e, t, i), 0), o.v(this.TAG, "Parsed AVCDecoderConfigurationRecord"), this._isInitialMetadataDispatched() ? this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack) : this._videoInitialMetadataDispatched = !0, this._dispatch = !1, this._onTrackMetadata("video", s)
		}
		_parseAVCVideoData(e, t, i, s, r, n, A) {
			let h = this._littleEndian,
				d = new DataView(e, t, i),
				_ = [],
				S = 0,
				u = 0;
			const B = this._naluLengthSize;
			let f = this._timestampBase + s,
				m = n === 1;
			for (; u < i;) {
				if (u + 4 >= i) {
					o.w(this.TAG, `Malformed Nalu near timestamp ${f}, offset = ${u}, dataSize = ${i}`);
					break
				}
				let c = d.getUint32(u, !h);
				if (B === 3 && (c >>>= 8), c > i - B) {
					o.w(this.TAG, `Malformed Nalus near timestamp ${f}, NaluSize > DataSize!`);
					return
				}
				let p = d.getUint8(u + B) & 31;
				p === 5 && (m = !0);
				let x = new Uint8Array(e, t + u, B + c),
					b = {
						type: p,
						data: x
					};
				_.push(b), S += x.byteLength, u += B + c
			}
			if (_.length) {
				let c = this._videoTrack,
					p = {
						units: _,
						length: S,
						isKeyframe: m,
						dts: f,
						cts: A,
						pts: f + A
					};
				m && (p.fileposition = r), c.samples.push(p), c.length += S
			}
		}
	}
	class l {
		static init() {
			l.types = {
				avc1: [],
				avcC: [],
				btrt: [],
				dinf: [],
				dref: [],
				esds: [],
				ftyp: [],
				hdlr: [],
				mdat: [],
				mdhd: [],
				mdia: [],
				mfhd: [],
				minf: [],
				moof: [],
				moov: [],
				mp4a: [],
				mvex: [],
				mvhd: [],
				sdtp: [],
				stbl: [],
				stco: [],
				stsc: [],
				stsd: [],
				stsz: [],
				stts: [],
				tfdt: [],
				tfhd: [],
				traf: [],
				trak: [],
				trun: [],
				trex: [],
				tkhd: [],
				vmhd: [],
				smhd: [],
				".mp3": []
			};
			for (let t in l.types) l.types.hasOwnProperty(t) && (l.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
			let e = l.constants = {};
			e.FTYP = new Uint8Array([105, 115, 111, 109, 0, 0, 0, 1, 105, 115, 111, 109, 97, 118, 99, 49]), e.STSD_PREFIX = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), e.STTS = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSC = e.STCO = e.STTS, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.HDLR_VIDEO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), e.HDLR_AUDIO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), e.DREF = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
		}
		static box(e) {
			let t = 8,
				i = null,
				s = Array.prototype.slice.call(arguments, 1),
				r = s.length;
			for (let A = 0; A < r; A++) t += s[A].byteLength;
			i = new Uint8Array(t), i[0] = t >>> 24 & 255, i[1] = t >>> 16 & 255, i[2] = t >>> 8 & 255, i[3] = t & 255, i.set(e, 4);
			let n = 8;
			for (let A = 0; A < r; A++) i.set(s[A], n), n += s[A].byteLength;
			return i
		}
		static generateInitSegment(e) {
			let t = l.box(l.types.ftyp, l.constants.FTYP),
				i = l.moov(e),
				s = new Uint8Array(t.byteLength + i.byteLength);
			return s.set(t, 0), s.set(i, t.byteLength), s
		}
		static moov(e) {
			let t = l.mvhd(e.timescale, e.duration),
				i = l.trak(e),
				s = l.mvex(e);
			return l.box(l.types.moov, t, i, s)
		}
		static mvhd(e, t) {
			return l.box(l.types.mvhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]))
		}
		static trak(e) {
			return l.box(l.types.trak, l.tkhd(e), l.mdia(e))
		}
		static tkhd(e) {
			let t = e.id,
				i = e.duration,
				s = e.presentWidth,
				r = e.presentHeight;
			return l.box(l.types.tkhd, new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255, 0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, s >>> 8 & 255, s & 255, 0, 0, r >>> 8 & 255, r & 255, 0, 0]))
		}
		static mdia(e) {
			return l.box(l.types.mdia, l.mdhd(e), l.hdlr(e), l.minf(e))
		}
		static mdhd(e) {
			let t = e.timescale,
				i = e.duration;
			return l.box(l.types.mdhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i & 255, 85, 196, 0, 0]))
		}
		static hdlr(e) {
			let t = null;
			return e.type === "audio" ? t = l.constants.HDLR_AUDIO : t = l.constants.HDLR_VIDEO, l.box(l.types.hdlr, t)
		}
		static minf(e) {
			let t = null;
			return e.type === "audio" ? t = l.box(l.types.smhd, l.constants.SMHD) : t = l.box(l.types.vmhd, l.constants.VMHD), l.box(l.types.minf, t, l.dinf(), l.stbl(e))
		}
		static dinf() {
			return l.box(l.types.dinf, l.box(l.types.dref, l.constants.DREF))
		}
		static stbl(e) {
			return l.box(l.types.stbl, l.stsd(e), l.box(l.types.stts, l.constants.STTS), l.box(l.types.stsc, l.constants.STSC), l.box(l.types.stsz, l.constants.STSZ), l.box(l.types.stco, l.constants.STCO))
		}
		static stsd(e) {
			return e.type === "audio" ? e.codec === "mp3" ? l.box(l.types.stsd, l.constants.STSD_PREFIX, l.mp3(e)) : l.box(l.types.stsd, l.constants.STSD_PREFIX, l.mp4a(e)) : l.box(l.types.stsd, l.constants.STSD_PREFIX, l.avc1(e))
		}
		static mp3(e) {
			let t = e.channelCount,
				i = e.audioSampleRate,
				s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t, 0, 16, 0, 0, 0, 0, i >>> 8 & 255, i & 255, 0, 0]);
			return l.box(l.types[".mp3"], s)
		}
		static mp4a(e) {
			let t = e.channelCount,
				i = e.audioSampleRate,
				s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t, 0, 16, 0, 0, 0, 0, i >>> 8 & 255, i & 255, 0, 0]);
			return l.box(l.types.mp4a, s, l.esds(e))
		}
		static esds(e) {
			let t = e.config || [],
				i = t.length,
				s = new Uint8Array([0, 0, 0, 0, 3, 23 + i, 0, 1, 0, 4, 15 + i, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([i]).concat(t).concat([6, 1, 2]));
			return l.box(l.types.esds, s)
		}
		static avc1(e) {
			let t = e.avcc,
				i = e.codecWidth,
				s = e.codecHeight,
				r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, i >>> 8 & 255, i & 255, s >>> 8 & 255, s & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 10, 120, 113, 113, 47, 102, 108, 118, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]);
			return l.box(l.types.avc1, r, l.box(l.types.avcC, t))
		}
		static mvex(e) {
			return l.box(l.types.mvex, l.trex(e))
		}
		static trex(e) {
			let t = e.id,
				i = new Uint8Array([0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]);
			return l.box(l.types.trex, i)
		}
		static moof(e, t) {
			return l.box(l.types.moof, l.mfhd(e.sequenceNumber), l.traf(e, t))
		}
		static mfhd(e) {
			let t = new Uint8Array([0, 0, 0, 0, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, e & 255]);
			return l.box(l.types.mfhd, t)
		}
		static traf(e, t) {
			let i = e.id,
				s = l.box(l.types.tfhd, new Uint8Array([0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i & 255])),
				r = l.box(l.types.tfdt, new Uint8Array([0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255])),
				n = l.sdtp(e),
				A = l.trun(e, n.byteLength + 16 + 16 + 8 + 16 + 8 + 8);
			return l.box(l.types.traf, s, r, A, n)
		}
		static sdtp(e) {
			let t = e.samples || [],
				i = t.length,
				s = new Uint8Array(4 + i);
			for (let r = 0; r < i; r++) {
				let n = t[r].flags;
				s[r + 4] = n.isLeading << 6 | n.dependsOn << 4 | n.isDependedOn << 2 | n.hasRedundancy
			}
			return l.box(l.types.sdtp, s)
		}
		static trun(e, t) {
			let i = e.samples || [],
				s = i.length,
				r = 12 + 16 * s,
				n = new Uint8Array(r);
			t += 8 + r, n.set([0, 0, 15, 1, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, s & 255, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255], 0);
			for (let A = 0; A < s; A++) {
				let h = i[A].duration,
					d = i[A].size,
					_ = i[A].flags,
					S = i[A].cts;
				n.set([h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, h & 255, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, d & 255, _.isLeading << 2 | _.dependsOn, _.isDependedOn << 6 | _.hasRedundancy << 4 | _.isNonSync, 0, 0, S >>> 24 & 255, S >>> 16 & 255, S >>> 8 & 255, S & 255], 12 + 16 * A)
			}
			return l.box(l.types.trun, n)
		}
		static mdat(e) {
			return l.box(l.types.mdat, e)
		}
	}
	l.init();
	class we {
		static getSilentFrame(e, t) {
			if (e === "mp4a.40.2") {
				if (t === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]);
				if (t === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
				if (t === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
				if (t === 4) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
				if (t === 5) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
				if (t === 6) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
			} else {
				if (t === 1) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
				if (t === 2) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
				if (t === 3) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
			}
			return null
		}
	}
	class ne {
		constructor(e, t, i, s, r) {
			this.dts = e, this.pts = t, this.duration = i, this.originalDts = s, this.isSyncPoint = r, this.fileposition = null
		}
	}
	class Re {
		constructor() {
			this.beginDts = 0, this.endDts = 0, this.beginPts = 0, this.endPts = 0, this.originalBeginDts = 0, this.originalEndDts = 0, this.syncPoints = [], this.firstSample = null, this.lastSample = null
		}
		appendSyncPoint(e) {
			e.isSyncPoint = !0, this.syncPoints.push(e)
		}
	}
	class He {
		constructor() {
			this._list = []
		}
		clear() {
			this._list = []
		}
		appendArray(e) {
			let t = this._list;
			e.length !== 0 && (t.length > 0 && e[0].originalDts < t[t.length - 1].originalDts && this.clear(), Array.prototype.push.apply(t, e))
		}
		getLastSyncPointBeforeDts(e) {
			if (this._list.length == 0) return null;
			let t = this._list,
				i = 0,
				s = t.length - 1,
				r = 0,
				n = 0,
				A = s;
			for (e < t[0].dts && (i = 0, n = A + 1); n <= A;)
				if (r = n + Math.floor((A - n) / 2), r === s || e >= t[r].dts && e < t[r + 1].dts) {
					i = r;
					break
				} else t[r].dts < e ? n = r + 1 : A = r - 1;
			return this._list[i]
		}
	}
	class ye {
		constructor(e) {
			this._type = e, this._list = [], this._lastAppendLocation = -1
		}
		get type() {
			return this._type
		}
		get length() {
			return this._list.length
		}
		isEmpty() {
			return this._list.length === 0
		}
		clear() {
			this._list = [], this._lastAppendLocation = -1
		}
		_searchNearestSegmentBefore(e) {
			let t = this._list;
			if (t.length === 0) return -2;
			let i = t.length - 1,
				s = 0,
				r = 0,
				n = i,
				A = 0;
			if (e < t[0].originalBeginDts) return A = -1, A;
			for (; r <= n;)
				if (s = r + Math.floor((n - r) / 2), s === i || e > t[s].lastSample.originalDts && e < t[s + 1].originalBeginDts) {
					A = s;
					break
				} else t[s].originalBeginDts < e ? r = s + 1 : n = s - 1;
			return A
		}
		_searchNearestSegmentAfter(e) {
			return this._searchNearestSegmentBefore(e) + 1
		}
		append(e) {
			let t = this._list,
				i = e,
				s = this._lastAppendLocation,
				r = 0;
			s !== -1 && s < t.length && i.originalBeginDts >= t[s].lastSample.originalDts && (s === t.length - 1 || s < t.length - 1 && i.originalBeginDts < t[s + 1].originalBeginDts) ? r = s + 1 : t.length > 0 && (r = this._searchNearestSegmentBefore(i.originalBeginDts) + 1), this._lastAppendLocation = r, this._list.splice(r, 0, i)
		}
		getLastSegmentBefore(e) {
			let t = this._searchNearestSegmentBefore(e);
			return t >= 0 ? this._list[t] : null
		}
		getLastSampleBefore(e) {
			let t = this.getLastSegmentBefore(e);
			return t != null ? t.lastSample : null
		}
		getLastSyncPointBefore(e) {
			let t = this._searchNearestSegmentBefore(e),
				i = this._list[t].syncPoints;
			for (; i.length === 0 && t > 0;) t--, i = this._list[t].syncPoints;
			return i.length > 0 ? i[i.length - 1] : null
		}
	}
	class Qe {
		constructor(e) {
			this.TAG = "MP4Remuxer", this._config = e, this._isLive = e.isLive === !0, this._dtsBase = -1, this._dtsBaseInited = !1, this._audioDtsBase = Infinity, this._videoDtsBase = Infinity, this._audioNextDts = void 0, this._videoNextDts = void 0, this._audioStashedLastSample = null, this._videoStashedLastSample = null, this._audioMeta = null, this._videoMeta = null, this._audioSegmentInfoList = new ye("audio"), this._videoSegmentInfoList = new ye("video"), this._onInitSegment = null, this._onMediaSegment = null, this._forceFirstIDR = !!(R.chrome && (R.version.major < 50 || R.version.major === 50 && R.version.build < 2661)), this._fillSilentAfterSeek = R.msedge || R.msie, this._mp3UseMpegAudio = !R.firefox, this._fillAudioTimestampGap = this._config.fixAudioTimestampGap
		}
		destroy() {
			this._dtsBase = -1, this._dtsBaseInited = !1, this._audioMeta = null, this._videoMeta = null, this._audioSegmentInfoList.clear(), this._audioSegmentInfoList = null, this._videoSegmentInfoList.clear(), this._videoSegmentInfoList = null, this._onInitSegment = null, this._onMediaSegment = null
		}
		bindDataSource(e) {
			return e.onDataAvailable = this.remux.bind(this), e.onTrackMetadata = this._onTrackMetadataReceived.bind(this), this
		}
		get onInitSegment() {
			return this._onInitSegment
		}
		set onInitSegment(e) {
			this._onInitSegment = e
		}
		get onMediaSegment() {
			return this._onMediaSegment
		}
		set onMediaSegment(e) {
			this._onMediaSegment = e
		}
		insertDiscontinuity() {
			this._audioNextDts = this._videoNextDts = void 0
		}
		seek(e) {
			this._audioStashedLastSample = null, this._videoStashedLastSample = null, this._videoSegmentInfoList.clear(), this._audioSegmentInfoList.clear()
		}
		remux(e, t) {
			if (!this._onMediaSegment) throw new G("MP4Remuxer: onMediaSegment callback must be specificed!");
			this._dtsBaseInited || this._calculateDtsBase(e, t), this._remuxVideo(t), this._remuxAudio(e)
		}
		_onTrackMetadataReceived(e, t) {
			let i = null,
				s = "mp4",
				r = t.codec;
			if (e === "audio") this._audioMeta = t, t.codec === "mp3" && this._mp3UseMpegAudio ? (s = "mpeg", r = "", i = new Uint8Array) : i = l.generateInitSegment(t);
			else if (e === "video") this._videoMeta = t, i = l.generateInitSegment(t);
			else return;
			if (!this._onInitSegment) throw new G("MP4Remuxer: onInitSegment callback must be specified!");
			this._onInitSegment(e, {
				type: e,
				data: i.buffer,
				codec: r,
				container: `${e}/${s}`,
				mediaDuration: t.duration
			})
		}
		_calculateDtsBase(e, t) {
			this._dtsBaseInited || (e.samples && e.samples.length && (this._audioDtsBase = e.samples[0].dts), t.samples && t.samples.length && (this._videoDtsBase = t.samples[0].dts), this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase), this._dtsBaseInited = !0)
		}
		flushStashedSamples() {
			let e = this._videoStashedLastSample,
				t = this._audioStashedLastSample,
				i = {
					type: "video",
					id: 1,
					sequenceNumber: 0,
					samples: [],
					length: 0
				};
			e != null && (i.samples.push(e), i.length = e.length);
			let s = {
				type: "audio",
				id: 2,
				sequenceNumber: 0,
				samples: [],
				length: 0
			};
			t != null && (s.samples.push(t), s.length = t.length), this._videoStashedLastSample = null, this._audioStashedLastSample = null, this._remuxVideo(i, !0), this._remuxAudio(s, !0)
		}
		_remuxAudio(e, t) {
			if (this._audioMeta == null) return;
			let i = e,
				s = i.samples,
				r, n = -1,
				A = -1,
				h = this._audioMeta.refSampleDuration,
				d = this._audioMeta.codec === "mp3" && this._mp3UseMpegAudio,
				_ = this._dtsBaseInited && this._audioNextDts === void 0,
				S = !1;
			if (!s || s.length === 0 || s.length === 1 && !t) return;
			let u = 0,
				B = null,
				f = 0;
			d ? (u = 0, f = i.length) : (u = 8, f = 8 + i.length);
			let m = null;
			if (s.length > 1 && (m = s.pop(), f -= m.length), this._audioStashedLastSample != null) {
				let C = this._audioStashedLastSample;
				this._audioStashedLastSample = null, s.unshift(C), f += C.length
			}
			m != null && (this._audioStashedLastSample = m);
			let c = s[0].dts - this._dtsBase;
			if (this._audioNextDts) r = c - this._audioNextDts;
			else if (this._audioSegmentInfoList.isEmpty()) r = 0, this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty() && this._audioMeta.originalCodec !== "mp3" && (S = !0);
			else {
				let C = this._audioSegmentInfoList.getLastSampleBefore(c);
				if (C != null) {
					let g = c - (C.originalDts + C.duration);
					g <= 3 && (g = 0);
					let U = C.dts + C.duration + g;
					r = c - U
				} else r = 0
			}
			if (S) {
				let C = c - r,
					g = this._videoSegmentInfoList.getLastSegmentBefore(c);
				if (g != null && g.beginDts < C) {
					let U = we.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);
					if (U) {
						let F = g.beginDts,
							L = C - g.beginDts;
						o.v(this.TAG, `InsertPrefixSilentAudio: dts: ${F}, duration: ${L}`), s.unshift({
							unit: U,
							dts: F,
							pts: F
						}), f += U.byteLength
					}
				} else S = !1
			}
			let p = [];
			for (let C = 0; C < s.length; C++) {
				let g = s[C],
					U = g.unit,
					F = g.dts - this._dtsBase,
					L = F - r;
				n === -1 && (n = L);
				let k = 0;
				C !== s.length - 1 ? k = s[C + 1].dts - this._dtsBase - r - L : m != null ? k = m.dts - this._dtsBase - r - L : p.length >= 1 ? k = p[p.length - 1].duration : k = Math.floor(h);
				let ge = !1,
					Y = null;
				if (k > h * 1.5 && this._audioMeta.codec !== "mp3" && this._fillAudioTimestampGap && !R.safari) {
					ge = !0;
					let J = Math.abs(k - h),
						$ = Math.ceil(J / h),
						ee = L + h;
					o.w(this.TAG, `Large audio timestamp gap detected, may cause AV sync to drift. Silent frames will be generated to avoid unsync.\ndts: ${L+k} ms, expected: ${L+Math.round(h)} ms, delta: ${Math.round(J)} ms, generate: ${$} frames`);
					let X = we.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);
					X == null && (o.w(this.TAG, `Unable to generate silent frame for ${this._audioMeta.originalCodec} with ${this._audioMeta.channelCount} channels, repeat last frame`), X = U), Y = [];
					for (let M = 0; M < $; M++) {
						let N = Math.round(ee);
						if (Y.length > 0) {
							let Ie = Y[Y.length - 1];
							Ie.duration = N - Ie.dts
						}
						let ue = {
							dts: N,
							pts: N,
							cts: 0,
							unit: X,
							size: X.byteLength,
							duration: 0,
							originalDts: F,
							flags: {
								isLeading: 0,
								dependsOn: 1,
								isDependedOn: 0,
								hasRedundancy: 0
							}
						};
						Y.push(ue), f += ue.size, ee += h
					}
					let de = Y[Y.length - 1];
					de.duration = L + k - de.dts, k = Math.round(h)
				}
				p.push({
					dts: L,
					pts: L,
					cts: 0,
					unit: g.unit,
					size: g.unit.byteLength,
					duration: k,
					originalDts: F,
					flags: {
						isLeading: 0,
						dependsOn: 1,
						isDependedOn: 0,
						hasRedundancy: 0
					}
				}), ge && p.push.apply(p, Y)
			}
			d ? B = new Uint8Array(f) : (B = new Uint8Array(f), B[0] = f >>> 24 & 255, B[1] = f >>> 16 & 255, B[2] = f >>> 8 & 255, B[3] = f & 255, B.set(l.types.mdat, 4));
			for (let C = 0; C < p.length; C++) {
				let g = p[C].unit;
				B.set(g, u), u += g.byteLength
			}
			let x = p[p.length - 1];
			A = x.dts + x.duration, this._audioNextDts = A;
			let b = new Re;
			b.beginDts = n, b.endDts = A, b.beginPts = n, b.endPts = A, b.originalBeginDts = p[0].originalDts, b.originalEndDts = x.originalDts + x.duration, b.firstSample = new ne(p[0].dts, p[0].pts, p[0].duration, p[0].originalDts, !1), b.lastSample = new ne(x.dts, x.pts, x.duration, x.originalDts, !1), this._isLive || this._audioSegmentInfoList.append(b), i.samples = p, i.sequenceNumber++;
			let I = null;
			d ? I = new Uint8Array : I = l.moof(i, n), i.samples = [], i.length = 0;
			let V = {
				type: "audio",
				data: this._mergeBoxes(I, B).buffer,
				sampleCount: p.length,
				info: b
			};
			d && _ && (V.timestampOffset = n), this._onMediaSegment("audio", V)
		}
		_remuxVideo(e, t) {
			if (this._videoMeta == null) return;
			let i = e,
				s = i.samples,
				r, n = -1,
				A = -1,
				h = -1,
				d = -1;
			if (!s || s.length === 0 || s.length === 1 && !t) return;
			let _ = 8,
				S = null,
				u = 8 + e.length,
				B = null;
			if (s.length > 1 && (B = s.pop(), u -= B.length), this._videoStashedLastSample != null) {
				let b = this._videoStashedLastSample;
				this._videoStashedLastSample = null, s.unshift(b), u += b.length
			}
			B != null && (this._videoStashedLastSample = B);
			let f = s[0].dts - this._dtsBase;
			if (this._videoNextDts) r = f - this._videoNextDts;
			else if (this._videoSegmentInfoList.isEmpty()) r = 0;
			else {
				let b = this._videoSegmentInfoList.getLastSampleBefore(f);
				if (b != null) {
					let I = f - (b.originalDts + b.duration);
					I <= 3 && (I = 0);
					let V = b.dts + b.duration + I;
					r = f - V
				} else r = 0
			}
			let m = new Re,
				c = [];
			for (let b = 0; b < s.length; b++) {
				let I = s[b],
					V = I.dts - this._dtsBase,
					C = I.isKeyframe,
					g = V - r,
					U = I.cts,
					F = g + U;
				n === -1 && (n = g, h = F);
				let L = 0;
				if (b !== s.length - 1 ? L = s[b + 1].dts - this._dtsBase - r - g : B != null ? L = B.dts - this._dtsBase - r - g : c.length >= 1 ? L = c[c.length - 1].duration : L = Math.floor(this._videoMeta.refSampleDuration), C) {
					let k = new ne(g, F, L, I.dts, !0);
					k.fileposition = I.fileposition, m.appendSyncPoint(k)
				}
				c.push({
					dts: g,
					pts: F,
					cts: U,
					units: I.units,
					size: I.length,
					isKeyframe: C,
					duration: L,
					originalDts: V,
					flags: {
						isLeading: 0,
						dependsOn: C ? 2 : 1,
						isDependedOn: C ? 1 : 0,
						hasRedundancy: 0,
						isNonSync: C ? 0 : 1
					}
				})
			}
			S = new Uint8Array(u), S[0] = u >>> 24 & 255, S[1] = u >>> 16 & 255, S[2] = u >>> 8 & 255, S[3] = u & 255, S.set(l.types.mdat, 4);
			for (let b = 0; b < c.length; b++) {
				let I = c[b].units;
				for (; I.length;) {
					let C = I.shift().data;
					S.set(C, _), _ += C.byteLength
				}
			}
			let p = c[c.length - 1];
			if (A = p.dts + p.duration, d = p.pts + p.duration, this._videoNextDts = A, m.beginDts = n, m.endDts = A, m.beginPts = h, m.endPts = d, m.originalBeginDts = c[0].originalDts, m.originalEndDts = p.originalDts + p.duration, m.firstSample = new ne(c[0].dts, c[0].pts, c[0].duration, c[0].originalDts, c[0].isKeyframe), m.lastSample = new ne(p.dts, p.pts, p.duration, p.originalDts, p.isKeyframe), this._isLive || this._videoSegmentInfoList.append(m), i.samples = c, i.sequenceNumber++, this._forceFirstIDR) {
				let b = c[0].flags;
				b.dependsOn = 2, b.isNonSync = 0
			}
			let x = l.moof(i, n);
			i.samples = [], i.length = 0, this._onMediaSegment("video", {
				type: "video",
				data: this._mergeBoxes(x, S).buffer,
				sampleCount: c.length,
				info: m
			})
		}
		_mergeBoxes(e, t) {
			let i = new Uint8Array(e.byteLength + t.byteLength);
			return i.set(e, 0), i.set(t, e.byteLength), i
		}
	}
	const E = {
		IO_ERROR: "io_error",
		DEMUX_ERROR: "demux_error",
		INIT_SEGMENT: "init_segment",
		MEDIA_SEGMENT: "media_segment",
		LOADING_COMPLETE: "loading_complete",
		RECOVERED_EARLY_EOF: "recovered_early_eof",
		MEDIA_INFO: "media_info",
		METADATA_ARRIVED: "metadata_arrived",
		SCRIPTDATA_ARRIVED: "scriptdata_arrived",
		STATISTICS_INFO: "statistics_info",
		RECOMMEND_SEEKPOINT: "recommend_seekpoint"
	};
	class je {
		constructor(e, t) {
			this.TAG = "TransmuxingController", this._emitter = new y, this._config = t, e.segments || (e.segments = [{
				duration: e.duration,
				filesize: e.filesize,
				url: e.url
			}]), typeof e.cors != "boolean" && (e.cors = !0), typeof e.withCredentials != "boolean" && (e.withCredentials = !1), this._mediaDataSource = e, this._currentSegmentIndex = 0;
			let i = 0;
			this._mediaDataSource.segments.forEach(s => {
				s.timestampBase = i, i += s.duration, s.cors = e.cors, s.withCredentials = e.withCredentials, t.referrerPolicy && (s.referrerPolicy = t.referrerPolicy)
			}), !isNaN(i) && this._mediaDataSource.duration !== i && (this._mediaDataSource.duration = i), this._mediaInfo = null, this._demuxer = null, this._remuxer = null, this._ioctl = null, this._pendingSeekTime = null, this._pendingResolveSeekPoint = null, this._statisticsReporter = null
		}
		destroy() {
			this._mediaInfo = null, this._mediaDataSource = null, this._statisticsReporter && this._disableStatisticsReporter(), this._ioctl && (this._ioctl.destroy(), this._ioctl = null), this._demuxer && (this._demuxer.destroy(), this._demuxer = null), this._remuxer && (this._remuxer.destroy(), this._remuxer = null), this._emitter.removeAllListeners(), this._emitter = null
		}
		on(e, t) {
			this._emitter.addListener(e, t)
		}
		off(e, t) {
			this._emitter.removeListener(e, t)
		}
		start() {
			this._loadSegment(0), this._enableStatisticsReporter()
		}
		_loadSegment(e, t) {
			this._currentSegmentIndex = e;
			let i = this._mediaDataSource.segments[e],
				s = this._ioctl = new fe(i, this._config, e);
			s.onError = this._onIOException.bind(this), s.onSeeked = this._onIOSeeked.bind(this), s.onComplete = this._onIOComplete.bind(this), s.onRedirect = this._onIORedirect.bind(this), s.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this), t ? this._demuxer.bindDataSource(this._ioctl) : s.onDataArrival = this._onInitChunkArrival.bind(this), s.open(t)
		}
		stop() {
			this._internalAbort(), this._disableStatisticsReporter()
		}
		_internalAbort() {
			this._ioctl && (this._ioctl.destroy(), this._ioctl = null)
		}
		pause() {
			this._ioctl && this._ioctl.isWorking() && (this._ioctl.pause(), this._disableStatisticsReporter())
		}
		resume() {
			this._ioctl && this._ioctl.isPaused() && (this._ioctl.resume(), this._enableStatisticsReporter())
		}
		seek(e) {
			if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) return;
			let t = this._searchSegmentIndexContains(e);
			if (t === this._currentSegmentIndex) {
				let i = this._mediaInfo.segments[t];
				if (i == null) this._pendingSeekTime = e;
				else {
					let s = i.getNearestKeyframe(e);
					this._remuxer.seek(s.milliseconds), this._ioctl.seek(s.fileposition), this._pendingResolveSeekPoint = s.milliseconds
				}
			} else {
				let i = this._mediaInfo.segments[t];
				if (i == null) this._pendingSeekTime = e, this._internalAbort(), this._remuxer.seek(), this._remuxer.insertDiscontinuity(), this._loadSegment(t);
				else {
					let s = i.getNearestKeyframe(e);
					this._internalAbort(), this._remuxer.seek(e), this._remuxer.insertDiscontinuity(), this._demuxer.resetMediaInfo(), this._demuxer.timestampBase = this._mediaDataSource.segments[t].timestampBase, this._loadSegment(t, s.fileposition), this._pendingResolveSeekPoint = s.milliseconds, this._reportSegmentMediaInfo(t)
				}
			}
			this._enableStatisticsReporter()
		}
		_searchSegmentIndexContains(e) {
			let t = this._mediaDataSource.segments,
				i = t.length - 1;
			for (let s = 0; s < t.length; s++)
				if (e < t[s].timestampBase) {
					i = s - 1;
					break
				} return i
		}
		_onInitChunkArrival(e, t) {
			let i = null,
				s = 0;
			if (t > 0) this._demuxer.bindDataSource(this._ioctl), this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase, s = this._demuxer.parseChunks(e, t);
			else if ((i = he.probe(e)).match) {
				this._demuxer = new he(i, this._config), this._remuxer || (this._remuxer = new Qe(this._config));
				let r = this._mediaDataSource;
				r.duration != null && !isNaN(r.duration) && (this._demuxer.overridedDuration = r.duration), typeof r.hasAudio == "boolean" && (this._demuxer.overridedHasAudio = r.hasAudio), typeof r.hasVideo == "boolean" && (this._demuxer.overridedHasVideo = r.hasVideo), this._demuxer.timestampBase = r.segments[this._currentSegmentIndex].timestampBase, this._demuxer.onError = this._onDemuxException.bind(this), this._demuxer.onMediaInfo = this._onMediaInfo.bind(this), this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this), this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this), this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl)), this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this), this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this), s = this._demuxer.parseChunks(e, t)
			} else i = null, o.e(this.TAG, "Non-FLV, Unsupported media type!"), Promise.resolve().then(() => {
				this._internalAbort()
			}), this._emitter.emit(E.DEMUX_ERROR, Q.FORMAT_UNSUPPORTED, "Non-FLV, Unsupported media type"), s = 0;
			return s
		}
		_onMediaInfo(e) {
			this._mediaInfo == null && (this._mediaInfo = Object.assign({}, e), this._mediaInfo.keyframesIndex = null, this._mediaInfo.segments = [], this._mediaInfo.segmentCount = this._mediaDataSource.segments.length, Object.setPrototypeOf(this._mediaInfo, le.prototype));
			let t = Object.assign({}, e);
			Object.setPrototypeOf(t, le.prototype), this._mediaInfo.segments[this._currentSegmentIndex] = t, this._reportSegmentMediaInfo(this._currentSegmentIndex), this._pendingSeekTime != null && Promise.resolve().then(() => {
				let i = this._pendingSeekTime;
				this._pendingSeekTime = null, this.seek(i)
			})
		}
		_onMetaDataArrived(e) {
			this._emitter.emit(E.METADATA_ARRIVED, e)
		}
		_onScriptDataArrived(e) {
			this._emitter.emit(E.SCRIPTDATA_ARRIVED, e)
		}
		_onIOSeeked() {
			this._remuxer.insertDiscontinuity()
		}
		_onIOComplete(e) {
			let i = e + 1;
			i < this._mediaDataSource.segments.length ? (this._internalAbort(), this._remuxer.flushStashedSamples(), this._loadSegment(i)) : (this._remuxer.flushStashedSamples(), this._emitter.emit(E.LOADING_COMPLETE), this._disableStatisticsReporter())
		}
		_onIORedirect(e) {
			let t = this._ioctl.extraData;
			this._mediaDataSource.segments[t].redirectedURL = e
		}
		_onIORecoveredEarlyEof() {
			this._emitter.emit(E.RECOVERED_EARLY_EOF)
		}
		_onIOException(e, t) {
			o.e(this.TAG, `IOException: type = ${e}, code = ${t.code}, msg = ${t.msg}`), this._emitter.emit(E.IO_ERROR, e, t), this._disableStatisticsReporter()
		}
		_onDemuxException(e, t) {
			o.e(this.TAG, `DemuxException: type = ${e}, info = ${t}`), this._emitter.emit(E.DEMUX_ERROR, e, t)
		}
		_onRemuxerInitSegmentArrival(e, t) {
			this._emitter.emit(E.INIT_SEGMENT, e, t)
		}
		_onRemuxerMediaSegmentArrival(e, t) {
			if (this._pendingSeekTime == null && (this._emitter.emit(E.MEDIA_SEGMENT, e, t), this._pendingResolveSeekPoint != null && e === "video")) {
				let i = t.info.syncPoints,
					s = this._pendingResolveSeekPoint;
				this._pendingResolveSeekPoint = null, R.safari && i.length > 0 && i[0].originalDts === s && (s = i[0].pts), this._emitter.emit(E.RECOMMEND_SEEKPOINT, s)
			}
		}
		_enableStatisticsReporter() {
			this._statisticsReporter == null && (this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval))
		}
		_disableStatisticsReporter() {
			this._statisticsReporter && (self.clearInterval(this._statisticsReporter), this._statisticsReporter = null)
		}
		_reportSegmentMediaInfo(e) {
			let t = this._mediaInfo.segments[e],
				i = Object.assign({}, t);
			i.duration = this._mediaInfo.duration, i.segmentCount = this._mediaInfo.segmentCount, delete i.segments, delete i.keyframesIndex, this._emitter.emit(E.MEDIA_INFO, i)
		}
		_reportStatisticsInfo() {
			let e = {};
			e.url = this._ioctl.currentURL, e.hasRedirect = this._ioctl.hasRedirect, e.hasRedirect && (e.redirectedURL = this._ioctl.currentRedirectedURL), e.speed = this._ioctl.currentSpeed, e.loaderType = this._ioctl.loaderType, e.currentSegmentIndex = this._currentSegmentIndex, e.totalSegmentCount = this._mediaDataSource.segments.length, this._emitter.emit(E.STATISTICS_INFO, e)
		}
	}
	class Ve {
		constructor(e, t) {
			if (this.TAG = "Transmuxer", this._emitter = new y, this._controller = new je(e, t), this._controller) {
				let i = this._controller;
				i.on(E.IO_ERROR, this._onIOError.bind(this)), i.on(E.DEMUX_ERROR, this._onDemuxError.bind(this)), i.on(E.INIT_SEGMENT, this._onInitSegment.bind(this)), i.on(E.MEDIA_SEGMENT, this._onMediaSegment.bind(this)), i.on(E.LOADING_COMPLETE, this._onLoadingComplete.bind(this)), i.on(E.RECOVERED_EARLY_EOF, this._onRecoveredEarlyEof.bind(this)), i.on(E.MEDIA_INFO, this._onMediaInfo.bind(this)), i.on(E.METADATA_ARRIVED, this._onMetaDataArrived.bind(this)), i.on(E.SCRIPTDATA_ARRIVED, this._onScriptDataArrived.bind(this)), i.on(E.STATISTICS_INFO, this._onStatisticsInfo.bind(this)), i.on(E.RECOMMEND_SEEKPOINT, this._onRecommendSeekpoint.bind(this))
			}
		}
		destroy() {
			this._controller.destroy(), this._controller = null, this._emitter.removeAllListeners(), this._emitter = null
		}
		on(e, t) {
			this._emitter.addListener(e, t)
		}
		off(e, t) {
			this._emitter.removeListener(e, t)
		}
		hasWorker() {
			return this._worker != null
		}
		open() {
			this._controller.start()
		}
		close() {
			this._controller.stop()
		}
		seek(e) {
			this._controller.seek(e)
		}
		pause() {
			this._controller.pause()
		}
		resume() {
			this._controller.resume()
		}
		_onInitSegment(e, t) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.INIT_SEGMENT, e, t)
			})
		}
		_onMediaSegment(e, t) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.MEDIA_SEGMENT, e, t)
			})
		}
		_onLoadingComplete() {
			Promise.resolve().then(() => {
				this._emitter.emit(E.LOADING_COMPLETE)
			})
		}
		_onRecoveredEarlyEof() {
			Promise.resolve().then(() => {
				this._emitter.emit(E.RECOVERED_EARLY_EOF)
			})
		}
		_onMediaInfo(e) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.MEDIA_INFO, e)
			})
		}
		_onMetaDataArrived(e) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.METADATA_ARRIVED, e)
			})
		}
		_onScriptDataArrived(e) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.SCRIPTDATA_ARRIVED, e)
			})
		}
		_onStatisticsInfo(e) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.STATISTICS_INFO, e)
			})
		}
		_onIOError(e, t) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.IO_ERROR, e, t)
			})
		}
		_onDemuxError(e, t) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.DEMUX_ERROR, e, t)
			})
		}
		_onRecommendSeekpoint(e) {
			Promise.resolve().then(() => {
				this._emitter.emit(E.RECOMMEND_SEEKPOINT, e)
			})
		}
	}
	const q = {
		ERROR: "error",
		SOURCE_OPEN: "source_open",
		UPDATE_END: "update_end",
		BUFFER_FULL: "buffer_full"
	};
	class Ye {
		constructor(e) {
			this.TAG = "MSEController", this._config = e, this._emitter = new y, this._config.isLive && this._config.autoCleanupSourceBuffer == null && (this._config.autoCleanupSourceBuffer = !0), this.e = {
				onSourceOpen: this._onSourceOpen.bind(this),
				onSourceEnded: this._onSourceEnded.bind(this),
				onSourceClose: this._onSourceClose.bind(this),
				onSourceBufferError: this._onSourceBufferError.bind(this),
				onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)
			}, this._mediaSource = null, this._mediaSourceObjectURL = null, this._mediaElement = null, this._isBufferFull = !1, this._hasPendingEos = !1, this._requireSetMediaDuration = !1, this._pendingMediaDuration = 0, this._pendingSourceBufferInit = [], this._mimeTypes = {
				video: null,
				audio: null
			}, this._sourceBuffers = {
				video: null,
				audio: null
			}, this._lastInitSegments = {
				video: null,
				audio: null
			}, this._pendingSegments = {
				video: [],
				audio: []
			}, this._pendingRemoveRanges = {
				video: [],
				audio: []
			}, this._idrList = new He
		}
		destroy() {
			(this._mediaElement || this._mediaSource) && this.detachMediaElement(), this.e = null, this._emitter.removeAllListeners(), this._emitter = null
		}
		on(e, t) {
			this._emitter.addListener(e, t)
		}
		off(e, t) {
			this._emitter.removeListener(e, t)
		}
		attachMediaElement(e) {
			if (this._mediaSource) throw new G("MediaSource has been attached to an HTMLMediaElement!");
			let t = this._mediaSource = new window.MediaSource;
			t.addEventListener("sourceopen", this.e.onSourceOpen), t.addEventListener("sourceended", this.e.onSourceEnded), t.addEventListener("sourceclose", this.e.onSourceClose), this._mediaElement = e, this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource), e.src = this._mediaSourceObjectURL
		}
		detachMediaElement() {
			if (this._mediaSource) {
				let e = this._mediaSource;
				for (let t in this._sourceBuffers) {
					let i = this._pendingSegments[t];
					i.splice(0, i.length), this._pendingSegments[t] = null, this._pendingRemoveRanges[t] = null, this._lastInitSegments[t] = null;
					let s = this._sourceBuffers[t];
					if (s) {
						if (e.readyState !== "closed") {
							try {
								e.removeSourceBuffer(s)
							} catch (r) {
								o.e(this.TAG, r.message)
							}
							s.removeEventListener("error", this.e.onSourceBufferError), s.removeEventListener("updateend", this.e.onSourceBufferUpdateEnd)
						}
						this._mimeTypes[t] = null, this._sourceBuffers[t] = null
					}
				}
				if (e.readyState === "open") try {
					e.endOfStream()
				} catch (t) {
					o.e(this.TAG, t.message)
				}
				e.removeEventListener("sourceopen", this.e.onSourceOpen), e.removeEventListener("sourceended", this.e.onSourceEnded), e.removeEventListener("sourceclose", this.e.onSourceClose), this._pendingSourceBufferInit = [], this._isBufferFull = !1, this._idrList.clear(), this._mediaSource = null
			}
			this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src"), this._mediaElement = null), this._mediaSourceObjectURL && (window.URL.revokeObjectURL(this._mediaSourceObjectURL), this._mediaSourceObjectURL = null)
		}
		appendInitSegment(e, t) {
			if (!this._mediaSource || this._mediaSource.readyState !== "open") {
				this._pendingSourceBufferInit.push(e), this._pendingSegments[e.type].push(e);
				return
			}
			let i = e,
				s = `${i.container}`;
			i.codec && i.codec.length > 0 && (s += `;codecs=${i.codec}`);
			let r = !1;
			if (o.v(this.TAG, "Received Initialization Segment, mimeType: " + s), this._lastInitSegments[i.type] = i, s !== this._mimeTypes[i.type]) {
				if (this._mimeTypes[i.type]) o.v(this.TAG, `Notice: ${i.type} mimeType changed, origin: ${this._mimeTypes[i.type]}, target: ${s}`);
				else {
					r = !0;
					try {
						let n = this._sourceBuffers[i.type] = this._mediaSource.addSourceBuffer(s);
						n.addEventListener("error", this.e.onSourceBufferError), n.addEventListener("updateend", this.e.onSourceBufferUpdateEnd)
					} catch (n) {
						o.e(this.TAG, n.message), this._emitter.emit(q.ERROR, {
							code: n.code,
							msg: n.message
						});
						return
					}
				}
				this._mimeTypes[i.type] = s
			}
			t || this._pendingSegments[i.type].push(i), r || this._sourceBuffers[i.type] && !this._sourceBuffers[i.type].updating && this._doAppendSegments(), R.safari && i.container === "audio/mpeg" && i.mediaDuration > 0 && (this._requireSetMediaDuration = !0, this._pendingMediaDuration = i.mediaDuration / 1e3, this._updateMediaSourceDuration())
		}
		appendMediaSegment(e) {
			let t = e;
			this._pendingSegments[t.type].push(t), this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer() && this._doCleanupSourceBuffer();
			let i = this._sourceBuffers[t.type];
			i && !i.updating && !this._hasPendingRemoveRanges() && this._doAppendSegments()
		}
		seek(e) {
			for (let t in this._sourceBuffers) {
				if (!this._sourceBuffers[t]) continue;
				let i = this._sourceBuffers[t];
				if (this._mediaSource.readyState === "open") try {
					i.abort()
				} catch (r) {
					o.e(this.TAG, r.message)
				}
				this._idrList.clear();
				let s = this._pendingSegments[t];
				if (s.splice(0, s.length), this._mediaSource.readyState !== "closed") {
					for (let r = 0; r < i.buffered.length; r++) {
						let n = i.buffered.start(r),
							A = i.buffered.end(r);
						this._pendingRemoveRanges[t].push({
							start: n,
							end: A
						})
					}
					if (i.updating || this._doRemoveRanges(), R.safari) {
						let r = this._lastInitSegments[t];
						r && (this._pendingSegments[t].push(r), i.updating || this._doAppendSegments())
					}
				}
			}
		}
		endOfStream() {
			let e = this._mediaSource,
				t = this._sourceBuffers;
			if (!e || e.readyState !== "open") {
				e && e.readyState === "closed" && this._hasPendingSegments() && (this._hasPendingEos = !0);
				return
			}
			t.video && t.video.updating || t.audio && t.audio.updating ? this._hasPendingEos = !0 : (this._hasPendingEos = !1, e.endOfStream())
		}
		getNearestKeyframe(e) {
			return this._idrList.getLastSyncPointBeforeDts(e)
		}
		_needCleanupSourceBuffer() {
			if (!this._config.autoCleanupSourceBuffer) return !1;
			let e = this._mediaElement.currentTime;
			for (let t in this._sourceBuffers) {
				let i = this._sourceBuffers[t];
				if (i) {
					let s = i.buffered;
					if (s.length >= 1 && e - s.start(0) >= this._config.autoCleanupMaxBackwardDuration) return !0
				}
			}
			return !1
		}
		_doCleanupSourceBuffer() {
			let e = this._mediaElement.currentTime;
			for (let t in this._sourceBuffers) {
				let i = this._sourceBuffers[t];
				if (i) {
					let s = i.buffered,
						r = !1;
					for (let n = 0; n < s.length; n++) {
						let A = s.start(n),
							h = s.end(n);
						if (A <= e && e < h + 3) {
							if (e - A >= this._config.autoCleanupMaxBackwardDuration) {
								r = !0;
								let d = e - this._config.autoCleanupMinBackwardDuration;
								this._pendingRemoveRanges[t].push({
									start: A,
									end: d
								})
							}
						} else h < e && (r = !0, this._pendingRemoveRanges[t].push({
							start: A,
							end: h
						}))
					}
					r && !i.updating && this._doRemoveRanges()
				}
			}
		}
		_updateMediaSourceDuration() {
			let e = this._sourceBuffers;
			if (this._mediaElement.readyState === 0 || this._mediaSource.readyState !== "open" || e.video && e.video.updating || e.audio && e.audio.updating) return;
			let t = this._mediaSource.duration,
				i = this._pendingMediaDuration;
			i > 0 && (isNaN(t) || i > t) && (o.v(this.TAG, `Update MediaSource duration from ${t} to ${i}`), this._mediaSource.duration = i), this._requireSetMediaDuration = !1, this._pendingMediaDuration = 0
		}
		_doRemoveRanges() {
			for (let e in this._pendingRemoveRanges) {
				if (!this._sourceBuffers[e] || this._sourceBuffers[e].updating) continue;
				let t = this._sourceBuffers[e],
					i = this._pendingRemoveRanges[e];
				for (; i.length && !t.updating;) {
					let s = i.shift();
					t.remove(s.start, s.end)
				}
			}
		}
		_doAppendSegments() {
			let e = this._pendingSegments;
			for (let t in e)
				if (!(!this._sourceBuffers[t] || this._sourceBuffers[t].updating) && e[t].length > 0) {
					let i = e[t].shift();
					if (i.timestampOffset) {
						let s = this._sourceBuffers[t].timestampOffset,
							r = i.timestampOffset / 1e3;
						Math.abs(s - r) > .1 && (o.v(this.TAG, `Update MPEG audio timestampOffset from ${s} to ${r}`), this._sourceBuffers[t].timestampOffset = r), delete i.timestampOffset
					}
					if (!i.data || i.data.byteLength === 0) continue;
					try {
						this._sourceBuffers[t].appendBuffer(i.data), this._isBufferFull = !1, t === "video" && i.hasOwnProperty("info") && this._idrList.appendArray(i.info.syncPoints)
					} catch (s) {
						this._pendingSegments[t].unshift(i), s.code === 22 ? (this._isBufferFull || this._emitter.emit(q.BUFFER_FULL), this._isBufferFull = !0) : (o.e(this.TAG, s.message), this._emitter.emit(q.ERROR, {
							code: s.code,
							msg: s.message
						}))
					}
				}
		}
		_onSourceOpen() {
			if (o.v(this.TAG, "MediaSource onSourceOpen"), this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen), this._pendingSourceBufferInit.length > 0) {
				let e = this._pendingSourceBufferInit;
				for (; e.length;) {
					let t = e.shift();
					this.appendInitSegment(t, !0)
				}
			}
			this._hasPendingSegments() && this._doAppendSegments(), this._emitter.emit(q.SOURCE_OPEN)
		}
		_onSourceEnded() {
			o.v(this.TAG, "MediaSource onSourceEnded")
		}
		_onSourceClose() {
			o.v(this.TAG, "MediaSource onSourceClose"), this._mediaSource && this.e != null && (this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen), this._mediaSource.removeEventListener("sourceended", this.e.onSourceEnded), this._mediaSource.removeEventListener("sourceclose", this.e.onSourceClose))
		}
		_hasPendingSegments() {
			let e = this._pendingSegments;
			return e.video.length > 0 || e.audio.length > 0
		}
		_hasPendingRemoveRanges() {
			let e = this._pendingRemoveRanges;
			return e.video.length > 0 || e.audio.length > 0
		}
		_onSourceBufferUpdateEnd() {
			this._requireSetMediaDuration ? this._updateMediaSourceDuration() : this._hasPendingRemoveRanges() ? this._doRemoveRanges() : this._hasPendingSegments() ? this._doAppendSegments() : this._hasPendingEos && this.endOfStream(), this._emitter.emit(q.UPDATE_END)
		}
		_onSourceBufferError(e) {
			o.e(this.TAG, `SourceBuffer Error: ${e}`)
		}
	}
	const me = {
			NETWORK_ERROR: "NetworkError",
			MEDIA_ERROR: "MediaError",
			OTHER_ERROR: "OtherError"
		},
		ze = {
			NETWORK_EXCEPTION: T.EXCEPTION,
			NETWORK_STATUS_CODE_INVALID: T.HTTP_STATUS_CODE_INVALID,
			NETWORK_TIMEOUT: T.CONNECTING_TIMEOUT,
			NETWORK_UNRECOVERABLE_EARLY_EOF: T.UNRECOVERABLE_EARLY_EOF,
			MEDIA_MSE_ERROR: "MediaMSEError",
			MEDIA_FORMAT_ERROR: Q.FORMAT_ERROR,
			MEDIA_FORMAT_UNSUPPORTED: Q.FORMAT_UNSUPPORTED,
			MEDIA_CODEC_UNSUPPORTED: Q.CODEC_UNSUPPORTED
		};
	class We {
		constructor(e, t) {
			if (this.TAG = "FlvPlayer", this._type = "FlvPlayer", this._emitter = new y, this._config = se(), typeof t == "object" && Object.assign(this._config, t), e.type.toLowerCase() !== "flv") throw new j("FlvPlayer requires an flv MediaDataSource input!");
			e.isLive === !0 && (this._config.isLive = !0), this.e = {
				onvLoadedMetadata: this._onvLoadedMetadata.bind(this),
				onvSeeking: this._onvSeeking.bind(this),
				onvCanPlay: this._onvCanPlay.bind(this),
				onvStalled: this._onvStalled.bind(this),
				onvProgress: this._onvProgress.bind(this)
			}, self.performance && self.performance.now ? this._now = self.performance.now.bind(self.performance) : this._now = Date.now, this._pendingSeekTime = null, this._requestSetTime = !1, this._seekpointRecord = null, this._progressChecker = null, this._mediaDataSource = e, this._mediaElement = null, this._msectl = null, this._transmuxer = null, this._mseSourceOpened = !1, this._hasPendingLoad = !1, this._receivedCanPlay = !1, this._mediaInfo = null, this._statisticsInfo = null;
			let i = R.chrome && (R.version.major < 50 || R.version.major === 50 && R.version.build < 2661);
			this._alwaysSeekKeyframe = !!(i || R.msedge || R.msie), this._alwaysSeekKeyframe && (this._config.accurateSeek = !1)
		}
		destroy() {
			this._progressChecker != null && (window.clearInterval(this._progressChecker), this._progressChecker = null), this._transmuxer && this.unload(), this._mediaElement && this.detachMediaElement(), this.e = null, this._mediaDataSource = null, this._emitter.removeAllListeners(), this._emitter = null
		}
		on(e, t) {
			e === v.MEDIA_INFO ? this._mediaInfo != null && Promise.resolve().then(() => {
				this._emitter.emit(v.MEDIA_INFO, this.mediaInfo)
			}) : e === v.STATISTICS_INFO && this._statisticsInfo != null && Promise.resolve().then(() => {
				this._emitter.emit(v.STATISTICS_INFO, this.statisticsInfo)
			}), this._emitter.addListener(e, t)
		}
		off(e, t) {
			this._emitter.removeListener(e, t)
		}
		attachMediaElement(e) {
			if (this._mediaElement = e, e.addEventListener("loadedmetadata", this.e.onvLoadedMetadata), e.addEventListener("seeking", this.e.onvSeeking), e.addEventListener("canplay", this.e.onvCanPlay), e.addEventListener("stalled", this.e.onvStalled), e.addEventListener("progress", this.e.onvProgress), this._msectl = new Ye(this._config), this._msectl.on(q.UPDATE_END, this._onmseUpdateEnd.bind(this)), this._msectl.on(q.BUFFER_FULL, this._onmseBufferFull.bind(this)), this._msectl.on(q.SOURCE_OPEN, () => {
					this._mseSourceOpened = !0, this._hasPendingLoad && (this._hasPendingLoad = !1, this.load())
				}), this._msectl.on(q.ERROR, t => {
					this._emitter.emit(v.ERROR, me.MEDIA_ERROR, ze.MEDIA_MSE_ERROR, t)
				}), this._msectl.attachMediaElement(e), this._pendingSeekTime != null) try {
				e.currentTime = this._pendingSeekTime, this._pendingSeekTime = null
			} catch (t) {}
		}
		detachMediaElement() {
			this._mediaElement && (this._msectl.detachMediaElement(), this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._mediaElement.removeEventListener("seeking", this.e.onvSeeking), this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay), this._mediaElement.removeEventListener("stalled", this.e.onvStalled), this._mediaElement.removeEventListener("progress", this.e.onvProgress), this._mediaElement = null), this._msectl && (this._msectl.destroy(), this._msectl = null)
		}
		load() {
			if (!this._mediaElement) throw new G("HTMLMediaElement must be attached before load()!");
			if (this._transmuxer) throw new G("FlvPlayer.load() has been called, please call unload() first!");
			if (!this._hasPendingLoad) {
				if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === !1) {
					this._hasPendingLoad = !0;
					return
				}
				this._mediaElement.readyState > 0 && (this._requestSetTime = !0, this._mediaElement.currentTime = 0), this._transmuxer = new Ve(this._mediaDataSource, this._config), this._transmuxer.on(E.INIT_SEGMENT, (e, t) => {
					this._msectl.appendInitSegment(t)
				}), this._transmuxer.on(E.MEDIA_SEGMENT, (e, t) => {
					if (this._msectl.appendMediaSegment(t), this._config.lazyLoad && !this._config.isLive) {
						let i = this._mediaElement.currentTime;
						t.info.endDts >= (i + this._config.lazyLoadMaxDuration) * 1e3 && this._progressChecker == null && (o.v(this.TAG, "Maximum buffering duration exceeded, suspend transmuxing task"), this._suspendTransmuxer())
					}
				}), this._transmuxer.on(E.LOADING_COMPLETE, () => {
					this._msectl.endOfStream(), this._emitter.emit(v.LOADING_COMPLETE)
				}), this._transmuxer.on(E.RECOVERED_EARLY_EOF, () => {
					this._emitter.emit(v.RECOVERED_EARLY_EOF)
				}), this._transmuxer.on(E.IO_ERROR, (e, t) => {
					this._emitter.emit(v.ERROR, me.NETWORK_ERROR, e, t)
				}), this._transmuxer.on(E.DEMUX_ERROR, (e, t) => {
					this._emitter.emit(v.ERROR, me.MEDIA_ERROR, e, {
						code: -1,
						msg: t
					})
				}), this._transmuxer.on(E.MEDIA_INFO, e => {
					this._mediaInfo = e, this._emitter.emit(v.MEDIA_INFO, Object.assign({}, e))
				}), this._transmuxer.on(E.METADATA_ARRIVED, e => {
					this._emitter.emit(v.METADATA_ARRIVED, e)
				}), this._transmuxer.on(E.SCRIPTDATA_ARRIVED, e => {
					this._emitter.emit(v.SCRIPTDATA_ARRIVED, e)
				}), this._transmuxer.on(E.STATISTICS_INFO, e => {
					this._statisticsInfo = this._fillStatisticsInfo(e), this._emitter.emit(v.STATISTICS_INFO, Object.assign({}, this._statisticsInfo))
				}), this._transmuxer.on(E.RECOMMEND_SEEKPOINT, e => {
					this._mediaElement && !this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = e / 1e3)
				}), this._transmuxer.open()
			}
		}
		unload() {
			this._mediaElement && this._mediaElement.pause(), this._msectl && this._msectl.seek(0), this._transmuxer && (this._transmuxer.close(), this._transmuxer.destroy(), this._transmuxer = null)
		}
		play() {
			return this._mediaElement.play()
		}
		pause() {
			this._mediaElement.pause()
		}
		get type() {
			return this._type
		}
		get buffered() {
			return this._mediaElement.buffered
		}
		get duration() {
			return this._mediaElement.duration
		}
		get volume() {
			return this._mediaElement.volume
		}
		set volume(e) {
			this._mediaElement.volume = e
		}
		get muted() {
			return this._mediaElement.muted
		}
		set muted(e) {
			this._mediaElement.muted = e
		}
		get currentTime() {
			return this._mediaElement ? this._mediaElement.currentTime : 0
		}
		set currentTime(e) {
			this._mediaElement ? this._internalSeek(e) : this._pendingSeekTime = e
		}
		get mediaInfo() {
			return Object.assign({}, this._mediaInfo)
		}
		get statisticsInfo() {
			return this._statisticsInfo == null && (this._statisticsInfo = {}), this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo), Object.assign({}, this._statisticsInfo)
		}
		_fillStatisticsInfo(e) {
			if (e.playerType = this._type, !(this._mediaElement instanceof HTMLVideoElement)) return e;
			let t = !0,
				i = 0,
				s = 0;
			if (this._mediaElement.getVideoPlaybackQuality) {
				let r = this._mediaElement.getVideoPlaybackQuality();
				i = r.totalVideoFrames, s = r.droppedVideoFrames
			} else this._mediaElement.webkitDecodedFrameCount != null ? (i = this._mediaElement.webkitDecodedFrameCount, s = this._mediaElement.webkitDroppedFrameCount) : t = !1;
			return t && (e.decodedFrames = i, e.droppedFrames = s), e
		}
		_onmseUpdateEnd() {
			if (!this._config.lazyLoad || this._config.isLive) return;
			let e = this._mediaElement.buffered,
				t = this._mediaElement.currentTime,
				i = 0;
			for (let s = 0; s < e.length; s++) {
				let r = e.start(s),
					n = e.end(s);
				if (r <= t && t < n) {
					i = n;
					break
				}
			}
			i >= t + this._config.lazyLoadMaxDuration && this._progressChecker == null && (o.v(this.TAG, "Maximum buffering duration exceeded, suspend transmuxing task"), this._suspendTransmuxer())
		}
		_onmseBufferFull() {
			o.v(this.TAG, "MSE SourceBuffer is full, suspend transmuxing task"), this._progressChecker == null && this._suspendTransmuxer()
		}
		_suspendTransmuxer() {
			this._transmuxer && (this._transmuxer.pause(), this._progressChecker == null && (this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1e3)))
		}
		_checkProgressAndResume() {
			let e = this._mediaElement.currentTime,
				t = this._mediaElement.buffered,
				i = !1;
			for (let s = 0; s < t.length; s++) {
				let r = t.start(s),
					n = t.end(s);
				if (e >= r && e < n) {
					e >= n - this._config.lazyLoadRecoverDuration && (i = !0);
					break
				}
			}
			i && (window.clearInterval(this._progressChecker), this._progressChecker = null, i && (o.v(this.TAG, "Continue loading from paused position"), this._transmuxer.resume()))
		}
		_isTimepointBuffered(e) {
			let t = this._mediaElement.buffered;
			for (let i = 0; i < t.length; i++) {
				let s = t.start(i),
					r = t.end(i);
				if (e >= s && e < r) return !0
			}
			return !1
		}
		_internalSeek(e) {
			let t = this._isTimepointBuffered(e),
				i = !1,
				s = 0;
			if (e < 1 && this._mediaElement.buffered.length > 0) {
				let r = this._mediaElement.buffered.start(0);
				(r < 1 && e < r || R.safari) && (i = !0, s = R.safari ? .1 : r)
			}
			if (i) this._requestSetTime = !0, this._mediaElement.currentTime = s;
			else if (t) {
				if (!this._alwaysSeekKeyframe) this._requestSetTime = !0, this._mediaElement.currentTime = e;
				else {
					let r = this._msectl.getNearestKeyframe(Math.floor(e * 1e3));
					this._requestSetTime = !0, r != null ? this._mediaElement.currentTime = r.dts / 1e3 : this._mediaElement.currentTime = e
				}
				this._progressChecker != null && this._checkProgressAndResume()
			} else this._progressChecker != null && (window.clearInterval(this._progressChecker), this._progressChecker = null), this._msectl.seek(e), this._transmuxer.seek(Math.floor(e * 1e3)), this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = e)
		}
		_checkAndApplyUnbufferedSeekpoint() {
			if (this._seekpointRecord)
				if (this._seekpointRecord.recordTime <= this._now() - 100) {
					let e = this._mediaElement.currentTime;
					this._seekpointRecord = null, this._isTimepointBuffered(e) || (this._progressChecker != null && (window.clearTimeout(this._progressChecker), this._progressChecker = null), this._msectl.seek(e), this._transmuxer.seek(Math.floor(e * 1e3)), this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = e))
				} else window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50)
		}
		_checkAndResumeStuckPlayback(e) {
			let t = this._mediaElement;
			if (e || !this._receivedCanPlay || t.readyState < 2) {
				let i = t.buffered;
				i.length > 0 && t.currentTime < i.start(0) && (o.w(this.TAG, `Playback seems stuck at ${t.currentTime}, seek to ${i.start(0)}`), this._requestSetTime = !0, this._mediaElement.currentTime = i.start(0), this._mediaElement.removeEventListener("progress", this.e.onvProgress))
			} else this._mediaElement.removeEventListener("progress", this.e.onvProgress)
		}
		_onvLoadedMetadata(e) {
			this._pendingSeekTime != null && (this._mediaElement.currentTime = this._pendingSeekTime, this._pendingSeekTime = null)
		}
		_onvSeeking(e) {
			let t = this._mediaElement.currentTime,
				i = this._mediaElement.buffered;
			if (this._requestSetTime) {
				this._requestSetTime = !1;
				return
			}
			if (t < 1 && i.length > 0) {
				let s = i.start(0);
				if (s < 1 && t < s || R.safari) {
					this._requestSetTime = !0, this._mediaElement.currentTime = R.safari ? .1 : s;
					return
				}
			}
			if (this._isTimepointBuffered(t)) {
				if (this._alwaysSeekKeyframe) {
					let s = this._msectl.getNearestKeyframe(Math.floor(t * 1e3));
					s != null && (this._requestSetTime = !0, this._mediaElement.currentTime = s.dts / 1e3)
				}
				this._progressChecker != null && this._checkProgressAndResume();
				return
			}
			this._seekpointRecord = {
				seekPoint: t,
				recordTime: this._now()
			}, window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50)
		}
		_onvCanPlay(e) {
			this._receivedCanPlay = !0, this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay)
		}
		_onvStalled(e) {
			this._checkAndResumeStuckPlayback(!0)
		}
		_onvProgress(e) {
			this._checkAndResumeStuckPlayback()
		}
	}
	class qe {
		constructor(e, t) {
			if (this.TAG = "NativePlayer", this._type = "NativePlayer", this._emitter = new y, this._config = se(), typeof t == "object" && Object.assign(this._config, t), e.type.toLowerCase() === "flv") throw new j("NativePlayer does't support flv MediaDataSource input!");
			if (e.hasOwnProperty("segments")) throw new j(`NativePlayer(${e.type}) doesn't support multipart playback!`);
			this.e = {
				onvLoadedMetadata: this._onvLoadedMetadata.bind(this)
			}, this._pendingSeekTime = null, this._statisticsReporter = null, this._mediaDataSource = e, this._mediaElement = null
		}
		destroy() {
			this._mediaElement && (this.unload(), this.detachMediaElement()), this.e = null, this._mediaDataSource = null, this._emitter.removeAllListeners(), this._emitter = null
		}
		on(e, t) {
			e === v.MEDIA_INFO ? this._mediaElement != null && this._mediaElement.readyState !== 0 && Promise.resolve().then(() => {
				this._emitter.emit(v.MEDIA_INFO, this.mediaInfo)
			}) : e === v.STATISTICS_INFO && this._mediaElement != null && this._mediaElement.readyState !== 0 && Promise.resolve().then(() => {
				this._emitter.emit(v.STATISTICS_INFO, this.statisticsInfo)
			}), this._emitter.addListener(e, t)
		}
		off(e, t) {
			this._emitter.removeListener(e, t)
		}
		attachMediaElement(e) {
			if (this._mediaElement = e, e.addEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._pendingSeekTime != null) try {
				e.currentTime = this._pendingSeekTime, this._pendingSeekTime = null
			} catch (t) {}
		}
		detachMediaElement() {
			this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src"), this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._mediaElement = null), this._statisticsReporter != null && (window.clearInterval(this._statisticsReporter), this._statisticsReporter = null)
		}
		load() {
			if (!this._mediaElement) throw new G("HTMLMediaElement must be attached before load()!");
			this._mediaElement.src = this._mediaDataSource.url, this._mediaElement.readyState > 0 && (this._mediaElement.currentTime = 0), this._mediaElement.preload = "auto", this._mediaElement.load(), this._statisticsReporter = window.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval)
		}
		unload() {
			this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src")), this._statisticsReporter != null && (window.clearInterval(this._statisticsReporter), this._statisticsReporter = null)
		}
		play() {
			return this._mediaElement.play()
		}
		pause() {
			this._mediaElement.pause()
		}
		get type() {
			return this._type
		}
		get buffered() {
			return this._mediaElement.buffered
		}
		get duration() {
			return this._mediaElement.duration
		}
		get volume() {
			return this._mediaElement.volume
		}
		set volume(e) {
			this._mediaElement.volume = e
		}
		get muted() {
			return this._mediaElement.muted
		}
		set muted(e) {
			this._mediaElement.muted = e
		}
		get currentTime() {
			return this._mediaElement ? this._mediaElement.currentTime : 0
		}
		set currentTime(e) {
			this._mediaElement ? this._mediaElement.currentTime = e : this._pendingSeekTime = e
		}
		get mediaInfo() {
			let t = {
				mimeType: (this._mediaElement instanceof HTMLAudioElement ? "audio/" : "video/") + this._mediaDataSource.type
			};
			return this._mediaElement && (t.duration = Math.floor(this._mediaElement.duration * 1e3), this._mediaElement instanceof HTMLVideoElement && (t.width = this._mediaElement.videoWidth, t.height = this._mediaElement.videoHeight)), t
		}
		get statisticsInfo() {
			let e = {
				playerType: this._type,
				url: this._mediaDataSource.url
			};
			if (!(this._mediaElement instanceof HTMLVideoElement)) return e;
			let t = !0,
				i = 0,
				s = 0;
			if (this._mediaElement.getVideoPlaybackQuality) {
				let r = this._mediaElement.getVideoPlaybackQuality();
				i = r.totalVideoFrames, s = r.droppedVideoFrames
			} else this._mediaElement.webkitDecodedFrameCount != null ? (i = this._mediaElement.webkitDecodedFrameCount, s = this._mediaElement.webkitDroppedFrameCount) : t = !1;
			return t && (e.decodedFrames = i, e.droppedFrames = s), e
		}
		_onvLoadedMetadata(e) {
			this._pendingSeekTime != null && (this._mediaElement.currentTime = this._pendingSeekTime, this._pendingSeekTime = null), this._emitter.emit(v.MEDIA_INFO, this.mediaInfo)
		}
		_reportStatisticsInfo() {
			this._emitter.emit(v.STATISTICS_INFO, this.statisticsInfo)
		}
	}

	function Ke(a, e) {
		let t = a;
		if (t == null || typeof t != "object") throw new j("MediaDataSource must be an javascript object!");
		if (!t.hasOwnProperty("type")) throw new j("MediaDataSource must has type field to indicate video file type!");
		switch (t.type) {
			case "flv":
				return new We(t, e);
			default:
				return new qe(t, e)
		}
	}

	function Je() {
		return re.supportMSEH264Playback()
	}

	function Xe() {
		let a = new OfflineAudioContext(1, 1, 44100);
		return Boolean(a.audioWorklet && typeof a.audioWorklet.addModule == "function")
	}

	function Ze() {
		class a extends AudioWorkletProcessor {
			constructor() {
				super();
				this.state = 0, this.start = !0, this.samplesArray = [], this.offset = 0, this.bufferSize = 1024, this.port.onmessage = t => {
					t.data.message == "init" ? this.bufferSize = t.data.bufferSize : t.data.message == "stop" ? this.start = !1 : t.data.message == "data" ? this.samplesArray.push(t.data.buffer) : t.data.message == "zero"
				}
			}
			process(t, i, s) {
				const n = i[0][0];
				if (this.offset == 0 && this.port.postMessage({
						message: "beep"
					}), this.state == 0 && (this.state = 1), this.state == 1 && this.samplesArray.length == 4 && (this.state = 2), this.state == 2) {
					let A = this.samplesArray[0];
					for (let h = 0; h < n.length; h++) n[h] = A[h + this.offset]
				} else n.fill(0);
				return this.offset += 128, this.offset == this.bufferSize && (this.offset = 0, this.state == 2 && this.samplesArray.shift(), this.samplesArray.length == 0 && (this.state = 0)), this.start
			}
		}
		registerProcessor("wa-processor", a)
	}

	function $e(a) {
		return a.trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1]
	}

	function et() {
		const a = $e(Ze.toString()),
			e = new Blob([a], {
				type: "text/javascript"
			});
		return URL.createObjectURL(e)
	}
	return Z.WAB = et, Z.AMF = H, Z
}();
typeof exports != "undefined" ? (typeof module != "undefined" && module.exports && (exports = module.exports = NodePlayer), exports.NodePlayer = NodePlayer) : Module.NodePlayer = NodePlayer, typeof define == "function" && define.amd && define([], function() {
	return NodePlayer
});